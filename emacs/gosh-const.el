;;; gosh-const.el --- Gauche constant settings

;; Author: Hayashi Masahiro <mhayashi1120@gmail.com>
;; Keywords: lisp gauche scheme
;; URL: https://github.com/mhayashi1120/Emacs-gosh-mode/raw/master/gosh-const.el
;; Emacs: GNU Emacs 22 or later

;; This program is free software; you can redistribute it and/or
;; modify it under the terms of the GNU General Public License as
;; published by the Free Software Foundation; either version 3, or (at
;; your option) any later version.

;; This program is distributed in the hope that it will be useful, but
;; WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
;; General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with GNU Emacs; see the file COPYING.  If not, write to the
;; Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
;; Boston, MA 02110-1301, USA.

;;; Commentary:
;; 

;;; Code:

(defvar current-language-environment)



(defconst gosh-const-procedure-keyword-list
  '( 
    ;; define methods
    "define" "define-class" "define-condition-type" "define-constant"
    "define-generic" "define-in-module" "define-macro" "define-method"
    "define-module" "define-record-type" "define-syntax" "define-values"

    "export" "export-if-defined" "export-all"

    "require"

    "^"
    "^a" "^b" "^c" "^d" "^e" "^f" "^g" "^h" "^i"
    "^j" "^k" "^l" "^m" "^n" "^o" "^p" "^q" "^r"
    "^s" "^t" "^u" "^v" "^w" "^x" "^y" "^z" 

    ;; keywords special indent function by `scheme-indent-function' property
    "and-let*" "begin0" "call-with-client-socket"
    "call-with-input-conversion" "call-with-input-file"
    "call-with-input-process" "call-with-input-string"
    "call-with-iterator" "call-with-output-conversion"
    "call-with-output-file" "call-with-output-string"
    "call-with-temporary-file" "call-with-values" "dolist" "dotimes"
    "guard" "if" "if-let1" "if-match" "let*-values" "let-args"
    "let-keywords*" "let-match" "let-optionals*" "let-syntax"
    "let-values" "let/cc" "let1" "letrec-syntax" "make" "match"
    "multiple-value-bind" "parameterize" "parse-options" "receive"
    "rlet1" "rxmatch-case" "rxmatch-cond" "rxmatch-if" "rxmatch-let"
    "select-module"
    "syntax-rules" "unwind-protect" "unless" "until" "when" "while"
    "with-builder" "with-error-handler" "with-error-to-port"
    "with-input-conversion" "with-input-from-port"
    "with-input-from-process" "with-input-from-string" "with-iterator"
    "with-locking-mutex" "with-module" "with-output-conversion"
    "with-output-to-port" "with-output-to-process"
    "with-output-to-string" "with-port-locking" "with-signal-handlers"
    "with-string-io" "with-time-counter"
    ))

(defconst gosh-defined-procedure-keyword-regexp
  (eval-when-compile
    (concat "(\\("
            (regexp-opt gosh-const-procedure-keyword-list)
            "\\)\\_>")))

(defconst gosh-basic-syntax-keyword-list
  '(
    "extend" "use" "import" "provide"
    ))

(defconst gosh-basic-syntax-keyword-regexp
  (eval-when-compile
    (concat "(" 
            (regexp-opt gosh-basic-syntax-keyword-list t)
            "[ \t]+\\(\\(?:\\sw\\|\\.\\)+\\)?")))

(defconst gosh-regexp-literal-regexp 
  "\\(#\\)\\(/\\)\\(\\(?:\\\\/\\|[^/]\\)+\\)\\(/\\)")

(defconst *gosh-scheme-r5rs-info*
  '((define (syntax (identifier value) undefined) "define a new variable")
    (set! (syntax (identifier value) undefined) "set the value of a variable")
    (let (syntax (vars body \.\.\.)) "bind new local variables in parallel")
    (let* (syntax (vars body \.\.\.)) "bind new local variables sequentially")
    (letrec (syntax (vars body \.\.\.)) "bind new local variables recursively")
    (lambda (syntax (params body \.\.\.)) "procedure syntax")
    (if (syntax (cond then else)) "conditional evaluation")
    (cond (syntax (clause \.\.\.)) "try each clause until one succeeds")
    (case (syntax (expr clause \.\.\.)) "look for EXPR among literal lists")
    (delay (syntax (expr)) "create a promise to evaluate EXPR")
    (and (syntax (expr \.\.\.)) "evaluate EXPRs while true, return last")
    (or (syntax (expr \.\.\.)) "return the first true EXPR")
    (begin (syntax (expr \.\.\.)) "evaluate each EXPR in turn and return the last")
    (do (syntax (vars finish body \.\.\.)) "simple iterator")
    (quote (syntax (expr)) "represent EXPR literally without evaluating it")
    (quasiquote (syntax (expr)) "quote literals allowing escapes")
    (unquote (syntax (expr)) "escape an expression inside quasiquote")
    (unquote-splicing (syntax (expr)) "escape and splice a list expression inside quasiquote")
    (define-syntax (syntax (identifier body \.\.\.) undefined) "create a macro")
    (let-syntax (syntax (syntaxes body \.\.\.)) "a local macro")
    (letrec-syntax (syntax (syntaxes body \.\.\.)) "a local macro")
    (syntax-rules (syntax (literals clauses \.\.\.) undefined) "simple macro language")
    (eqv? (lambda (obj1 obj2) bool) "returns #t if OBJ1 and OBJ2 are the same object")
    (eq? (lambda (obj1 obj2) bool) "finer grained version of EQV?")
    (equal? (lambda (obj1 obj2) bool) "recursive equivalence")
    (not (lambda (obj) bool) "returns #t iff OBJ is false")
    (boolean? (lambda (obj) bool) "returns #t iff OBJ is #t or #f")
    (number? (lambda (obj) bool) "returns #t iff OBJ is a number")
    (complex? (lambda (obj) bool) "returns #t iff OBJ is a complex number")
    (real? (lambda (obj) bool) "returns #t iff OBJ is a real number")
    (rational? (lambda (obj) bool) "returns #t iff OBJ is a rational number")
    (integer? (lambda (obj) bool) "returns #t iff OBJ is an integer")
    (exact? (lambda (z) bool) "returns #t iff Z is exact")
    (inexact? (lambda (z) bool) "returns #t iff Z is inexact")
    (= (lambda (z1 z2 \.\.\.) bool) "returns #t iff the arguments are all equal")
    (< (lambda (x1 x2 \.\.\.) bool) "returns #t iff the arguments are monotonically increasing")
    (> (lambda (x1 x2 \.\.\.) bool) "returns #t iff the arguments are monotonically decreasing")
    (<= (lambda (x1 x2 \.\.\.) bool) "returns #t iff the arguments are monotonically nondecreasing")
    (>= (lambda (x1 x2 \.\.\.) bool) "returns #t iff the arguments are monotonically nonincreasing")
    (zero? (lambda (z) bool))
    (positive? (lambda (x1) bool))
    (negative? (lambda (x1) bool))
    (odd? (lambda (n) bool))
    (even? (lambda (n) bool))
    (max (lambda (x1 x2 \.\.\.) x3) "returns the maximum of the arguments")
    (min (lambda (x1 x2 \.\.\.) x3) "returns the minimum of the arguments")
    (+ (lambda (z1 \.\.\.) z))
    (* (lambda (z1 \.\.\.) z))
    (- (lambda (z1 \.\.\.) z))
    (/ (lambda (z1 \.\.\.) z))
    (abs (lambda (x1) x2) "returns the absolute value of X")
    (quotient (lambda (n1 n2) n) "integer division")
    (remainder (lambda (n1 n2) n) "same sign as N1")
    (modulo (lambda (n1 n2) n) "same sign as N2")
    (gcd (lambda (n1 \.\.\.) n) "greatest common divisor")
    (lcm (lambda (n2 \.\.\.) n) "least common multiple")
    (numerator (lambda (rational) n))
    (denominator (lambda (rational) n))
    (floor (lambda (x1) n) "largest integer not larger than X")
    (ceiling (lambda (x1) n) "smallest integer not smaller than X")
    (truncate (lambda (x1) n) "drop fractional part")
    (round (lambda (x1) n) "round to even (banker's rounding)")
    (rationalize (lambda (x1 y) n) "rational number differing from X by at most Y")
    (exp (lambda (z) z) "e^Z")
    (log (lambda (z) z) "natural logarithm of Z")
    (sin (lambda (z) z) "sine function")
    (cos (lambda (z) z) "cosine function")
    (tan (lambda (z) z) "tangent function")
    (asin (lambda (z) z) "arcsine function")
    (acos (lambda (z) z) "arccosine function")
    (atan (lambda (z) z) "arctangent function")
    (sqrt (lambda (z) z) "principal square root of Z")
    (expt (lambda (z1 z2) z) "returns Z1 raised to the Z2 power")
    (make-rectangular (lambda (x1 x2) z) "create a complex number")
    (make-polar (lambda (x1 x2) z) "create a complex number")
    (real-part (lambda (z) x1))
    (imag-part (lambda (z) x1))
    (magnitude (lambda (z) x1))
    (angle (lambda (z) x1))
    (exact->inexact (lambda (z) z))
    (inexact->exact (lambda (z) z))
    (number->string (lambda (z :optional radix) str))
    (string->number (lambda (str :optional radix) z))
    (pair? (lambda (obj) bool) "returns #t iff OBJ is a pair")
    (cons (lambda (obj1 obj2) pair) "create a newly allocated pair")
    (car (lambda (pair) obj))
    (cdr (lambda (pair) obj))
    (set-car! (lambda (pair obj) undefined))
    (set-cdr! (lambda (pair obj) undefined))
    (caar (lambda (pair) obj))
    (cadr (lambda (pair) obj))
    (cdar (lambda (pair) obj))
    (cddr (lambda (pair) obj))
    (caaar (lambda (pair) obj))
    (caadr (lambda (pair) obj))
    (cadar (lambda (pair) obj))
    (caddr (lambda (pair) obj))
    (cdaar (lambda (pair) obj))
    (cdadr (lambda (pair) obj))
    (cddar (lambda (pair) obj))
    (cdddr (lambda (pair) obj))
    (caaaar (lambda (pair) obj))
    (caaadr (lambda (pair) obj))
    (caadar (lambda (pair) obj))
    (caaddr (lambda (pair) obj))
    (cadaar (lambda (pair) obj))
    (cadadr (lambda (pair) obj))
    (caddar (lambda (pair) obj))
    (cadddr (lambda (pair) obj))
    (cdaaar (lambda (pair) obj))
    (cdaadr (lambda (pair) obj))
    (cdadar (lambda (pair) obj))
    (cdaddr (lambda (pair) obj))
    (cddaar (lambda (pair) obj))
    (cddadr (lambda (pair) obj))
    (cdddar (lambda (pair) obj))
    (cddddr (lambda (pair) obj))
    (null? (lambda (obj) bool) "returns #t iff OBJ is the empty list")
    (list? (lambda (obj) bool) "returns #t iff OBJ is a proper list")
    (list (lambda (obj \.\.\.) list) "returns a newly allocated list")
    (length (lambda (list) n))
    (append (lambda (list \.\.\.) list) "concatenates the list arguments")
    (reverse (lambda (list) list))
    (list-tail (lambda (list k) list) "returns the Kth cdr of LIST")
    (list-ref (lambda (list k) obj) "returns the Kth element of LIST")
    (memq (lambda (obj list)) "the sublist of LIST whose car is eq? to OBJ")
    (memv (lambda (obj list)) "the sublist of LIST whose car is eqv? to OBJ")
    (member (lambda (obj list)) "the sublist of LIST whose car is equal? to OBJ")
    (assq (lambda (obj list)) "the element of LIST whose car is eq? to OBJ")
    (assv (lambda (obj list)) "the element of LIST whose car is eqv? to OBJ")
    (assoc (lambda (obj list)) "the element of LIST whose car is equal? to OBJ")
    (symbol? (lambda (obj) bool) "returns #t iff OBJ is a symbol")
    (symbol->string (lambda (symbol) str))
    (string->symbol (lambda (str) symbol))
    (char? (lambda (obj) bool) "returns #t iff OBJ is a character")
    (char=? (lambda (ch1 ch2) bool))
    (char<? (lambda (ch1 ch2) bool))
    (char>? (lambda (ch1 ch2) bool))
    (char<=? (lambda (ch1 ch2) bool))
    (char>=? (lambda (ch1 ch2) bool))
    (char-ci=? (lambda (ch1 ch2) bool))
    (char-ci<? (lambda (ch1 ch2) bool))
    (char-ci>? (lambda (ch1 ch2) bool))
    (char-ci<=? (lambda (ch1 ch2) bool))
    (char-ci>=? (lambda (ch1 ch2) bool))
    (char-alphabetic? (lambda (ch) bool))
    (char-numeric? (lambda (ch) bool))
    (char-whitespace? (lambda (ch) bool))
    (char-upper-case? (lambda (ch) bool))
    (char-lower-case? (lambda (ch) bool))
    (char->integer (lambda (ch) int))
    (integer->char (lambda (int) ch))
    (char-upcase (lambda (ch) ch))
    (char-downcase (lambda (ch) ch))
    (string? (lambda (obj) bool) "returns #t iff OBJ is a string")
    (make-string (lambda (k :optional ch) str) "a new string of length k")
    (string (lambda (ch \.\.\.) str) "a new string made of the char arguments")
    (string-length (lambda (str) n) "the number of characters in STR")
    (string-ref (lambda (str i) ch) "the Ith character of STR")
    (string-set! (lambda (str i ch) undefined) "set the Ith character of STR to CH")
    (string=? (lambda (str1 str2) bool))
    (string-ci=? (lambda (str1 str2) bool))
    (string<? (lambda (str1 str2) bool))
    (string>? (lambda (str1 str2) bool))
    (string<=? (lambda (str1 str2) bool))
    (string>=? (lambda (str1 str2) bool))
    (string-ci<? (lambda (str1 str2) bool))
    (string-ci>? (lambda (str1 str2) bool))
    (string-ci<=? (lambda (str1 str2) bool))
    (string-ci>=? (lambda (str1 str2) bool))
    (substring (lambda (str start end) str))
    (string-append (lambda (str \.\.\.) str) "concatenate the string arguments")
    (string->list (lambda (str) list))
    (list->string (lambda (list) str))
    (string-copy (lambda (str) str))
    (string-fill! (lambda (str ch) undefined) "set every char in STR to CH")
    (vector? (lambda (obj) bool) "returns #t iff OBJ is a vector")
    (make-vector (lambda (len :optional fill) vec) "a new vector of K elements")
    (vector (lambda (obj \.\.\.) vec))
    (vector-length (lambda (vec) n) "the number of elements in VEC")
    (vector-ref (lambda (vec i) obj) "the Ith element of VEC")
    (vector-set! (lambda (vec i obj) undefined) "set the Ith element of VEC to OBJ")
    (vector->list (lambda (vec) list))
    (list->vector (lambda (list) vec))
    (vector-fill! (lambda (vec obj) undefined) "set every element in VEC to OBJ")
    (procedure? (lambda (obj) bool) "returns #t iff OBJ is a procedure")
    (apply (lambda ((lambda obj a) obj \.\.\.) a) "procedure application")
    (map (lambda ((lambda (obj1 . obj2) a) list \.\.\.) (list a)) "a new list of PROC applied to every element of LIST")
    (for-each (lambda ((lambda obj a) obj \.\.\.) undefined) "apply PROC to each element of LIST in order")
    (force (lambda (promise) obj) "force the delayed value of PROMISE")
    (call-with-current-continuation (lambda (proc) obj) "goto on steroids")
    (values (lambda (obj \.\.\.)) "send multiple values to the calling continuation")
    (call-with-values (lambda (producer consumer) obj))
    (dynamic-wind (lambda (before-thunk thunk after-thunk) obj))
    (scheme-report-environment (lambda (int) env) "INT should be 5")
    (null-environment (lambda (int) env) "INT should be 5")
    (call-with-input-file (lambda (path proc) input-port))
    (call-with-output-file (lambda (path proc) output-port))
    (input-port? (lambda (obj) bool) "returns #t iff OBJ is an input port")
    (output-port? (lambda (obj) bool) "returns #t iff OBJ is an output port")
    (current-input-port (lambda () input-port) "the default input for read procedures")
    (current-output-port (lambda () output-port) "the default output for write procedures")
    (with-input-from-file (lambda (path thunk) obj))
    (with-output-to-file (lambda (path thunk) obj))
    (open-input-file (lambda (path) input-port))
    (open-output-file (lambda (path) output-port))
    (close-input-port (lambda (input-port)))
    (close-output-port (lambda (output-port)))
    (read (lambda (:optional input-port) obj) "read a datum")
    (read-char (lambda (:optional input-port) ch) "read a single character")
    (peek-char (lambda (:optional input-port) ch))
    (eof-object? (lambda (obj) bool) "returns #t iff OBJ is the end-of-file object")
    (char-ready? (lambda (:optional input-port) bool))
    (write (lambda (object :optional output-port) undefined) "write a datum")
    (display (lambda (object :optional output-port) undefined) "display")
    (newline (lambda (:optional output-port) undefined) "send a linefeed")
    (write-char (lambda (char :optional output-port) undefined) "write a single character")
    (load (lambda (filename) undefined) "evaluate expressions from a file")
    (eval (lambda (expr env)))
    ))

(defconst *gosh-scheme-srfi-info*
  [
   ;; SRFI 0
   ("Feature-based conditional expansion construct"
    (cond-expand (syntax (clause \.\.\.))))
   
   ;; SRFI 1
   ("List Library"
    (xcons (lambda (object object) pair))
    (cons* (lambda (object \.\.\.) pair))
    (make-list (lambda (integer :optional object) list))
    (list-tabulate (lambda (integer procedure) list))
    (list-copy (lambda (list) list))
    (circular-list (lambda (object \.\.\.) list))
    (iota (lambda (integer :optional integer integer) list))
    (proper-list? (lambda (object) bool))
    (circular-list? (lambda (object) bool))
    (dotted-list? (lambda (object) bool))
    (not-pair? (lambda (object) bool))
    (null-list? (lambda (object) bool))
    (list= (lambda (procedure list \.\.\.) bool))
    (first (lambda (pair)))
    (second (lambda (pair)))
    (third (lambda (pair)))
    (fourth (lambda (pair)))
    (fifth (lambda (pair)))
    (sixth (lambda (pair)))
    (seventh (lambda (pair)))
    (eighth (lambda (pair)))
    (ninth (lambda (pair)))
    (tenth (lambda (pair)))
    (car+cdr (lambda (pair)))
    (take (lambda (pair integer) list))
    (drop (lambda (pair integer) list))
    (take-right (lambda (pair integer) list))
    (drop-right (lambda (pair integer) list))
    (take! (lambda (pair integer) list))
    (drop-right! (lambda (pair integer) list))
    (split-at (lambda (pair integer) list))
    (split-at! (lambda (pair integer) list))
    (last (lambda (pair) obj))
    (last-pair (lambda (pair) pair))
    (length+ (lambda (object) n))
    (concatenate (lambda (list) list))
    (append! (lambda (list \.\.\.) list))
    (concatenate! (lambda (list) list))
    (reverse! (lambda (list) list))
    (append-reverse (lambda (list list) list))
    (append-reverse! (lambda (list list) list))
    (zip (lambda (list \.\.\.) list))
    (unzip1 (lambda (list) list))
    (unzip2 (lambda (list) list))
    (unzip3 (lambda (list) list))
    (unzip4 (lambda (list) list))
    (unzip5 (lambda (list) list))
    (count (lambda ((lambda (obj1 . obj2)) list \.\.\.) n))
    (fold (lambda ((lambda (obj1 obj2 . obj3) a) object list \.\.\.) a))
    (unfold (lambda (procedure procedure procedure object :optional procedure) obj))
    (pair-fold (lambda ((lambda obj a) object list \.\.\.) a))
    (reduce (lambda ((lambda (obj1 obj2 . obj3) a) object list \.\.\.) a))
    (fold-right (lambda ((lambda (obj1 obj2 . obj3) a) object list \.\.\.) a))
    (unfold-right (lambda (procedure procedure procedure object :optional object) obj))
    (pair-fold-right (lambda ((lambda (obj1 obj2 . obj3) a) object list \.\.\.) a))
    (reduce-right (lambda ((lambda (obj1 obj2 . obj3) a) object list \.\.\.) a))
    (append-map (lambda ((lambda (obj1 . obj2)) list \.\.\.) list))
    (append-map! (lambda ((lambda (obj1 . obj2)) list \.\.\.) list))
    (map! (lambda ((lambda (obj1 . obj2)) list \.\.\.) list))
    (pair-for-each (lambda ((lambda (obj1 . obj2)) list \.\.\.) undefined))
    (filter-map (lambda ((lambda (obj1 . obj2)) list \.\.\.) list))
    (map-in-order (lambda ((lambda (obj1 . obj2)) list \.\.\.) list))
    (filter (lambda ((lambda (obj1 . obj2)) list) list))
    (partition (lambda ((lambda (obj) bool) list) list))
    (remove (lambda ((lambda (obj1) bool) list) list))
    (filter! (lambda ((lambda (obj1) bool) list) list))
    (partition! (lambda ((lambda (obj1) bool) list) list))
    (remove! (lambda ((lambda (obj1) bool) list) list))
    (find (lambda ((lambda (obj1) bool) list) obj))
    (find-tail (lambda ((lambda (obj1) bool) list) obj))
    (any (lambda ((lambda (obj1 . obj2) a) list \.\.\.) a))
    (every (lambda ((lambda (obj1 . obj2) a) list \.\.\.) a))
    (list-index (lambda ((lambda (obj1 . obj2)) list \.\.\.) (or bool integer)))
    (take-while (lambda ((lambda (obj)) list) list))
    (drop-while (lambda ((lambda (obj)) list) list))
    (take-while! (lambda ((lambda (obj)) list) list))
    (span (lambda ((lambda (obj)) list) list))
    (break (lambda ((lambda (obj)) list) list))
    (span! (lambda ((lambda (obj)) list) list))
    (break! (lambda ((lambda (obj)) list) list))
    (delete (lambda (object list :optional procedure) list))
    (delete-duplicates (lambda (list :optional procedure) list))
    (delete! (lambda (obj list :optional procedure) list))
    (delete-duplicates! (lambda (list :optional procedure) list))
    (alist-cons (lambda (obj1 obj2 alist) alist))
    (alist-copy (lambda (alist) alist))
    (alist-delete (lambda (obj alist) alist))
    (alist-delete! (lambda (obj alist) alist))
    (lset<= (lambda (procedure list \.\.\.) bool))
    (lset= (lambda (procedure list \.\.\.) bool))
    (lset-adjoin (lambda (procedure list object \.\.\.) list))
    (lset-union (lambda (procedure list \.\.\.) list))
    (lset-union! (lambda (procedure list \.\.\.) list))
    (lset-intersection (lambda (procedure list \.\.\.) list))
    (lset-intersection! (lambda (procedure list \.\.\.) list))
    (lset-difference (lambda (procedure list \.\.\.) list))
    (lset-difference! (lambda (procedure list \.\.\.) list))
    (lset-xor (lambda (procedure list \.\.\.) list))
    (lset-xor! (lambda (procedure list \.\.\.) list))
    (lset-diff+intersection (lambda (procedure list \.\.\.) list))
    (lset-diff+intersection! (lambda (procedure list \.\.\.) list))

    )

   ;; SRFI 2
   ("AND-LET*: an AND with local bindings, a guarded LET* special form"
    (and-let* (syntax (bindings body \.\.\.))))

   ()

   ;; SRFI 4
   ("Homogeneous numeric vector datatypes"

    (u8vector? (lambda (obj) bool))
    (make-u8vector (lambda (size integer) u8vector))
    (u8vector (lambda (integer \.\.\.) u8vector))
    (u8vector-length (lambda (u8vector) n))
    (u8vector-ref (lambda (u8vector i) int))
    (u8vector-set! (lambda (u8vector i u8value) undefined))
    (u8vector->list (lambda (u8vector) list))
    (list->u8vector (lambda (list) u8vector))

    (s8vector? (lambda (obj) bool))
    (make-s8vector (lambda (size integer) s8vector))
    (s8vector (lambda (integer \.\.\.) s8vector))
    (s8vector-length (lambda (s8vector) n))
    (s8vector-ref (lambda (s8vector i) int))
    (s8vector-set! (lambda (s8vector i s8value) undefined))
    (s8vector->list (lambda (s8vector) list))
    (list->s8vector (lambda (list) s8vector))

    (u16vector? (lambda (obj) bool))
    (make-u16vector (lambda (size integer) u16vector))
    (u16vector (lambda (integer \.\.\.)))
    (u16vector-length (lambda (u16vector) n))
    (u16vector-ref (lambda (u16vector i) int))
    (u16vector-set! (lambda (u16vector i u16value) undefined))
    (u16vector->list (lambda (u16vector) list))
    (list->u16vector (lambda (list) u16vector))

    (s16vector? (lambda (obj) bool))
    (make-s16vector (lambda (size integer) s16vector))
    (s16vector (lambda (integer \.\.\.) s16vector))
    (s16vector-length (lambda (s16vector) n))
    (s16vector-ref (lambda (s16vector i) int))
    (s16vector-set! (lambda (s16vector i s16value) undefined))
    (s16vector->list (lambda (s16vector) list))
    (list->s16vector (lambda (list) s16vector))

    (u32vector? (lambda (obj) bool))
    (make-u32vector (lambda (size integer) u32vector))
    (u32vector (lambda (integer \.\.\.) u32vector))
    (u32vector-length (lambda (u32vector) n))
    (u32vector-ref (lambda (u32vector i) int))
    (u32vector-set! (lambda (u32vector i u32value) undefined))
    (u32vector->list (lambda (u32vector) list))
    (list->u32vector (lambda (list) u32vector))

    (s32vector? (lambda (obj) bool))
    (make-s32vector (lambda (size integer) s32vector))
    (s32vector (lambda (integer \.\.\.) s32vector))
    (s32vector-length (lambda (s32vector) n))
    (s32vector-ref (lambda (s32vector i) int))
    (s32vector-set! (lambda (s32vector i s32value) undefined))
    (s32vector->list (lambda (s32vector) list))
    (list->s32vector (lambda (list) s32vector))

    (u64vector? (lambda (obj) bool))
    (make-u64vector (lambda (size integer) u64vector))
    (u64vector (lambda (integer \.\.\.) u64vector))
    (u64vector-length (lambda (u64vector) n))
    (u64vector-ref (lambda (u64vector i) int))
    (u64vector-set! (lambda (u64vector i u64value) undefined))
    (u64vector->list (lambda (u64vector) list))
    (list->u64vector (lambda (list) u64vector))

    (s64vector? (lambda (obj) bool))
    (make-s64vector (lambda (size integer) s64vector))
    (s64vector (lambda (integer \.\.\.) s64vector))
    (s64vector-length (lambda (s64vector) n))
    (s64vector-ref (lambda (s64vector i) int))
    (s64vector-set! (lambda (s64vector i s64value) undefined))
    (s64vector->list (lambda (s64vector) list))
    (list->s64vector (lambda (list) s64vector))

    (f32vector? (lambda (obj) bool))
    (make-f32vector (lambda (size integer) f32vector))
    (f32vector (lambda (number \.\.\.) f32vector))
    (f32vector-length (lambda (f32vector) n))
    (f32vector-ref (lambda (f32vector i) int))
    (f32vector-set! (lambda (f32vector i f32value) undefined))
    (f32vector->list (lambda (f32vector) list))
    (list->f32vector (lambda (list) f32vector))

    (f64vector? (lambda (obj) bool))
    (make-f64vector (lambda (size integer) f64vector))
    (f64vector (lambda (number \.\.\.) f64vector))
    (f64vector-length (lambda (f64vector) n))
    (f64vector-ref (lambda (f64vector i) int))
    (f64vector-set! (lambda (f64vector i f64value) undefined))
    (f64vector->list (lambda (f64vector) list))
    (list->f64vector (lambda (list) f64vector))
    )

   ;; SRFI 5
   ("A compatible let form with signatures and rest arguments"
    (let (syntax (bindings body \.\.\.))))

   ;; SRFI 6
   ("Basic String Ports"
    (open-input-string (lambda (str) input-port))
    (open-output-string (lambda () output-port))
    (get-output-string (lambda (output-port) str)))

   ;; SRFI 7
   ("Feature-based program configuration language"
    (program (syntax (clause \.\.\.)))
    (feature-cond (syntax (clause))))

   ;; SRFI 8
   ("receive: Binding to multiple values"
    (receive (syntax (identifiers producer body \.\.\.))))

   ;; SRFI 9
   ("Defining Record Types"
    (define-record-type (syntax (name constructor-name pred-name fields \.\.\.))))

   ;; SRFI 10
   ("Sharp-Comma External Form"
    (define-reader-ctor (syntax (name proc) undefined)))

   ;; SRFI 11
   ("Syntax for receiving multiple values"
    (let-values (syntax (bindings body \.\.\.)))
    (let-values* (syntax (bindings body \.\.\.))))

   ()

   ;; SRFI 13
   ("String Library"
    (string-map (lambda (proc str :optional start end) str))
    (string-map! (lambda (proc str :optional start end) undefined))
    (string-fold (lambda (kons knil str :optional start end) obj))
    (string-fold-right (lambda (kons knil str :optional start end) obj))
    (string-unfold (lambda (p f g seed :optional base make-final) str))
    (string-unfold-right (lambda (p f g seed :optional base make-final) str))
    (string-tabulate (lambda (proc len) str))
    (string-for-each (lambda (proc str :optional start end) undefined))
    (string-for-each-index (lambda (proc str :optional start end) undefined))
    (string-every (lambda (pred str :optional start end) obj))
    (string-any (lambda (pred str :optional start end) obj))
    (string-hash (lambda (str :optional bound start end) int))
    (string-hash-ci (lambda (str :optional bound start end) int))
    (string-compare (lambda (string1 string2 lt-proc eq-proc gt-proc :optional start end) obj))
    (string-compare-ci (lambda (string1 string2 lt-proc eq-proc gt-proc :optional start end) obj))
    (string= (lambda (string1 string2 :optional start1 end1 start2 end2) bool))
    (string<> (lambda (string1 string2 :optional start1 end1 start2 end2) bool))
    (string< (lambda (string1 string2 :optional start1 end1 start2 end2) bool))
    (string> (lambda (string1 string2 :optional start1 end1 start2 end2) bool))
    (string<= (lambda (string1 string2 :optional start1 end1 start2 end2) bool))
    (string>= (lambda (string1 string2 :optional start1 end1 start2 end2) bool))
    (string-ci= (lambda (string1 string2 :optional start1 end1 start2 end2) bool))
    (string-ci<> (lambda (string1 string2 :optional start1 end1 start2 end2) bool))
    (string-ci< (lambda (string1 string2 :optional start1 end1 start2 end2) bool))
    (string-ci> (lambda (string1 string2 :optional start1 end1 start2 end2) bool))
    (string-ci<= (lambda (string1 string2 :optional start1 end1 start2 end2) bool))
    (string-ci>= (lambda (string1 string2 :optional start1 end1 start2 end2) bool))
    (string-titlecase (lambda (string :optional start end) str))
    (string-upcase (lambda (string :optional start end) str))
    (string-downcase (lambda (string :optional start end) str))
    (string-titlecase! (lambda (string :optional start end) undefined))
    (string-upcase! (lambda (string :optional start end) undefined))
    (string-downcase! (lambda (string :optional start end) undefined))
    (string-take (lambda (string nchars) str))
    (string-drop (lambda (string nchars) str))
    (string-take-right (lambda (string nchars) str))
    (string-drop-right (lambda (string nchars) str))
    (string-pad (lambda (string k :optional char start end) str))
    (string-pad-right (lambda (string k :optional char start end) str))
    (string-trim (lambda (string :optional char/char-set/pred start end) str))
    (string-trim-right (lambda (string :optional char/char-set/pred start end) str))
    (string-trim-both (lambda (string :optional char/char-set/pred start end) str))
    (string-filter (lambda (char/char-set/pred string :optional start end) str))
    (string-delete (lambda (char/char-set/pred string :optional start end) str))
    (string-index (lambda (string char/char-set/pred :optional start end) (or integer bool)))
    (string-index-right (lambda (string char/char-set/pred :optional end start) (or integer bool)))
    (string-skip (lambda (string char/char-set/pred :optional start end) (or integer bool)))
    (string-skip-right (lambda (string char/char-set/pred :optional end start) (or integer bool)))
    (string-count (lambda (string char/char-set/pred :optional start end) n))
    (string-prefix-length (lambda (string1 string2 :optional start1 end1 start2 end2) n))
    (string-suffix-length (lambda (string1 string2 :optional start1 end1 start2 end2) n))
    (string-prefix-length-ci (lambda (string1 string2 :optional start1 end1 start2 end2) n))
    (string-suffix-length-ci (lambda (string1 string2 :optional start1 end1 start2 end2) n))
    (string-prefix? (lambda (string1 string2 :optional start1 end1 start2 end2) bool))
    (string-suffix? (lambda (string1 string2 :optional start1 end1 start2 end2) bool))
    (string-prefix-ci? (lambda (string1 string2 :optional start1 end1 start2 end2) bool))
    (string-suffix-ci? (lambda (string1 string2 :optional start1 end1 start2 end2) bool))
    (string-contains (lambda (string pattern :optional s-start s-end p-start p-end) obj))
    (string-contains-ci (lambda (string pattern :optional s-start s-end p-start p-end) obj))
    (string-fill! (lambda (string char :optional start end) undefined))
    (string-copy! (lambda (to tstart from :optional fstart fend) undefined))
    (string-copy (lambda (str :optional start end) str))
    (substring/shared (lambda (str start :optional end) str))
    (string-reverse (lambda (str :optional start end) str))
    (string-reverse! (lambda (str :optional start end) undefined))
    (reverse-list->string (lambda (char-list) str))
    (string->list (lambda (str :optional start end) list))
    (string-concatenate (lambda (string-list) str))
    (string-concatenate/shared (lambda (string-list) str))
    (string-append/shared (lambda (str \.\.\.) str))
    (string-concatenate-reverse (lambda (string-list :optional final-string end) str))
    (string-concatenate-reverse/shared (lambda (string-list :optional final-string end) str))
    (xsubstring (lambda (str from :optional to start end) str))
    (string-xcopy! (lambda (target tstart str from :optional to start end) undefined))
    (string-null? (lambda (str) bool))
    (string-join (lambda (string-list :optional delim grammar) str))
    (string-tokenize (lambda (string :optional token-chars start end) str))
    (string-replace (lambda (str1 str2 start1 end1 :optional start2 end2) str))
    (string-kmp-partial-search (lambda (pat rv str i :optional c= p-start s-start s-end) n))
    (make-kmp-restart-vector (lambda (str :optional c= start end) vec))
    (kmp-step (lambda (pat rv c i c= p-start) n))
    )

   ;; SRFI 14
   ("Character-Set Library"
    (char-set? (lambda (cset) bool))
    (char-set= (lambda (cset \.\.\.) bool))
    (char-set<= (lambda (cset \.\.\.) bool))
    (char-set-hash (lambda (cset :optional int) int))
    (char-set-cursor (lambda (cset) cursor))
    (char-set-ref (lambda (cset cursor) ch))
    (char-set-cursor-next (lambda (cset cursor) int))
    (end-of-char-set? (lambda (cursor) bool))
    (char-set-fold (lambda (proc obj cset) obj))
    (char-set-unfold (lambda (proc proc proc obj :optional obj) cset))
    (char-set-unfold! (lambda (proc proc proc obj obj) cset))
    (char-set-for-each (lambda (proc cset) undefined))
    (char-set-map (lambda (proc cset) cset))
    (char-set-copy (lambda (cset) cset))
    (char-set (lambda (ch \.\.\.) cset))
    (list->char-set (lambda (list :optional obj) cset))
    (list->char-set! (lambda (list cset) cset))
    (string->char-set (lambda (str :optional cset) cset))
    (string->char-set! (lambda (str cset) cset))
    (ucs-range->char-set (lambda (int int :optional bool cset) cset))
    (ucs-range->char-set! (lambda (int int bool cset) cset))
    (char-set-filter (lambda (proc cset :optional base-cset) cset))
    (char-set-filter! (lambda (proc cset base-cset) cset))
    (->char-set (lambda (obj) cset))
    (char-set-size (lambda (cset) n))
    (char-set-count (lambda (proc cset) n))
    (char-set-contains? (lambda (cset ch) bool))
    (char-set-every (lambda (proc cset) obj))
    (char-set-any (lambda (proc cset) obj))
    (char-set-adjoin (lambda (cset ch \.\.\.) cset))
    (char-set-delete (lambda (cset ch \.\.\.) cset))
    (char-set-adjoin! (lambda (cset ch \.\.\.) cset))
    (char-set-delete! (lambda (cset ch \.\.\.) cset))
    (char-set->list (lambda (cset) list))
    (char-set->string (lambda (cset) str))
    (char-set-complement (lambda (cset) cset))
    (char-set-union (lambda (cset \.\.\.) cset))
    (char-set-intersection (lambda (cset \.\.\.) cset))
    (char-set-xor (lambda (cset \.\.\.) cset))
    (char-set-difference (lambda (cset \.\.\.) cset))
    (char-set-diff+intersection (lambda (cset \.\.\.) cset))
    (char-set-complement! (lambda (cset) cset))
    (char-set-union! (lambda (cset \.\.\.) cset))
    (char-set-intersection! (lambda (cset \.\.\.) cset))
    (char-set-xor! (lambda (cset \.\.\.) cset))
    (char-set-difference! (lambda (cset \.\.\.) cset))
    (char-set-diff+intersection! (lambda (cset \.\.\.) cset))
    (char-set:lower-case char-set)
    (char-set:upper-case char-set)
    (char-set:letter char-set)
    (char-set:digit char-set)
    (char-set:letter+digit char-set)
    (char-set:graphic char-set)
    (char-set:printing char-set)
    (char-set:whitespace char-set)
    (char-set:blank char-set)
    (char-set:iso-control char-set)
    (char-set:punctuation char-set)
    (char-set:symbol char-set)
    (char-set:hex-digit char-set)
    (char-set:ascii char-set)
    (char-set:empty char-set)
    (char-set:full char-set)
    )

   ()

   ;; SRFI 16
   ("Syntax for procedures of variable arity"
    (case-lambda (syntax (clauses \.\.\.) procedure)))

   ;; SRFI 17
   ("Generalized set!"
    (set! (syntax (what value) undefined)))

   ;; SRFI 18
   ("Multithreading support"
    (current-thread (lambda () thread))
    (thread? (lambda (obj) bool))
    (make-thread (lambda (thunk :optional name) thread))
    (thread-name (lambda (thread) name))
    (thread-specific (lambda (thread)))
    (thread-specific-set! (lambda (thread obj)))
    (thread-base-priority (lambda (thread)))
    (thread-base-priority-set! (lambda (thread number)))
    (thread-priority-boost (lambda (thread)))
    (thread-priority-boost-set! (lambda (thread number)))
    (thread-quantum (lambda (thread)))
    (thread-quantum-set! (lambda (thread number)))
    (thread-start! (lambda (thread)))
    (thread-yield! (lambda ()))
    (thread-sleep! (lambda (number)))
    (thread-terminate! (lambda (thread)))
    (thread-join! (lambda (thread :optional timeout timeout-val)))
    (mutex? (lambda (obj) bool))
    (make-mutex (lambda (:optional name) mutex))
    (mutex-name (lambda (mutex) name))
    (mutex-specific (lambda (mutex)))
    (mutex-specific-set! (lambda (mutex obj)))
    (mutex-state (lambda (mutex)))
    (mutex-lock! (lambda (mutex :optional timeout thread)))
    (mutex-unlock! (lambda (mutex :optional condition-variable timeout)))
    (condition-variable? (lambda (obj) bool))
    (make-condition-variable (lambda (:optional name) condition-variable))
    (condition-variable-name (lambda (condition-variable) name))
    (condition-variable-specific (lambda (condition-variable)))
    (condition-variable-specific-set! (lambda (condition-variable obj)))
    (condition-variable-signal! (lambda (condition-variable)))
    (condition-variable-broadcast! (lambda (condition-variable)))
    (current-time (lambda () time))
    (time? (lambda (obj) bool))
    (time->seconds (lambda (time) x1))
    (seconds->time (lambda (x1) time))
    (current-exception-handler (lambda () handler))
    (with-exception-handler (lambda (handler thunk)))
    (raise (lambda (obj)))
    (join-timeout-exception? (lambda (obj) bool))
    (abandoned-mutex-exception? (lambda (obj) bool))
    (terminated-thread-exception? (lambda (obj) bool))
    (uncaught-exception? (lambda (obj) bool))
    (uncaught-exception-reason (lambda (exc) obj))
    )

   ;; SRFI 19
   ("Time Data Types and Procedures"
    (current-date (lambda (:optional tz-offset)) date)
    (current-julian-day (lambda ()) jdn)
    (current-modified-julian-day (lambda ()) mjdn)
    (current-time (lambda (:optional time-type)) time)
    (time-resolution (lambda (:optional time-type)) nanoseconds)
    (make-time (lambda (type nanosecond second)))
    (time? (lambda (obj)))
    (time-type (lambda (time)))
    (time-nanosecond (lambda (time)))
    (time-second (lambda (time)))
    (set-time-type! (lambda (time)))
    (set-time-nanosecond! (lambda (time)))
    (set-time-second! (lambda (time)))
    (copy-time (lambda (time)))
    (time<=? (lambda (time1 time2)))
    (time<? (lambda (time1 time2)))
    (time=? (lambda (time1 time2)))
    (time>=? (lambda (time1 time2)))
    (time>? (lambda (time1 time2)))
    (time-difference (lambda (time1 time2)))
    (time-difference! (lambda (time1 time2)))
    (add-duration (lambda (time duration)))
    (add-duration! (lambda (time duration)))
    (subtract-duration (lambda (time duration)))
    (subtract-duration! (lambda (time duration)))
    (make-date (lambda (nanosecond second minute hour day month year zone-offset)))
    (date? (lambda (obj)))
    (date-nanosecond (lambda (date)))
    (date-second (lambda (date)))
    (date-minute (lambda (date)))
    (date-hour (lambda (date)))
    (date-day (lambda (date)))
    (date-month (lambda (date)))
    (date-year (lambda (date)))
    (date-zone-offset (lambda (date)))
    (date-year-day (lambda (date)))
    (date-week-day (lambda (date)))
    (date-week-number (lambda (date)))
    (date->julian-day (lambda (date)))
    (date->modified-julian-day (lambda (date)))
    (date->time-monotonic (lambda (date)))
    (date->time-tai (lambda (date)))
    (date->time-utc (lambda (date)))
    (julian-day->date (lambda (date)))
    (julian-day->time-monotonic (lambda (date)))
    (julian-day->time-tai (lambda (date)))
    (julian-day->time-utc (lambda (date)))
    (modified-julian-day->date (lambda (date)))
    (modified-julian-day->time-monotonic (lambda (date)))
    (modified-julian-day->time-tai (lambda (date)))
    (modified-julian-day->time-utc (lambda (date)))
    (time-monotonic->date (lambda (date)))
    (time-monotonic->julian-day (lambda (date)))
    (time-monotonic->modified-julian-day (lambda (date)))
    (time-monotonic->time-monotonic (lambda (date)))
    (time-monotonic->time-tai (lambda (date)))
    (time-monotonic->time-tai! (lambda (date)))
    (time-monotonic->time-utc (lambda (date)))
    (time-monotonic->time-utc! (lambda (date)))
    (time-tai->date (lambda (date)))
    (time-tai->julian-day (lambda (date)))
    (time-tai->modified-julian-day (lambda (date)))
    (time-tai->time-monotonic (lambda (date)))
    (time-tai->time-monotonic! (lambda (date)))
    (time-tai->time-utc (lambda (date)))
    (time-tai->time-utc! (lambda (date)))
    (time-utc->date (lambda (date)))
    (time-utc->julian-day (lambda (date)))
    (time-utc->modified-julian-day (lambda (date)))
    (time-utc->time-monotonic (lambda (date)))
    (time-utc->time-monotonic! (lambda (date)))
    (time-utc->time-tai (lambda (date)))
    (time-utc->time-tai! (lambda (date)))
    (date->string (lambda (date :optional format-string)))
    (string->date (lambda (input-string template-string)))
    )

   ()

   ;; SRFI 21
   ("Real-time multithreading support"
    srfi-18)                            ; same as srfi-18

   ;; SRFI 22
   ("Running Scheme Scripts on Unix"
    )

   ;; SRFI 23
   ("Error reporting mechanism"
    (error (lambda (reason-string arg \.\.\.))))

   ()

   ;; SRFI 25
   ("Multi-dimensional Array Primitives"
    (array? (lambda (obj)))
    (make-array (lambda (shape :optional init)))
    (shape (lambda (bound \.\.\.)))
    (array (lambda (shape obj \.\.\.)))
    (array-rank (lambda (array)))
    (array-start (lambda (array)))
    (array-end (lambda (array)))
    (array-shape (lambda (array)))
    (array-ref (lambda (array i \.\.\.)))
    (array-set! (lambda (array obj \.\.\.) undefined))
    (share-array (lambda (array shape proc)))
    )

   ;; SRFI 26
   ("Notation for Specializing Parameters without Currying"
    (cut (syntax (obj \.\.\.)))
    (cute (lambda (obj \.\.\.))))

   ;; SRFI 27
   ("Sources of Random Bits"
    (random-integer (lambda (n)))
    (random-real (lambda ()))
    (default-random-source (lambda ()))
    (make-random-source (lambda ()))
    (random-source? (lambda (obj)))
    (random-source-state-ref (lambda (random-source)))
    (random-source-state-set! (lambda (random-source state)))
    (random-source-randomize! (lambda (random-source)))
    (random-source-pseudo-randomize! (lambda (random-source i j)))
    (random-source-make-integers (lambda (random-source)))
    (random-source-make-reals (lambda (random-source)))
    )

   ;; SRFI 28
   ("Basic Format Strings"
    (format (lambda (port-or-boolean format-string arg \.\.\.))))

   ;; SRFI 29
   ("Localization"
    (current-language (lambda (:optional symbol)))
    (current-country (lambda (:optional symbol)))
    (current-locale-details (lambda (:optional list)))
    (declare-bundle! (lambda (bundle-name association-list)))
    (store-bundle (lambda (bundle-name)))
    (load-bundle! (lambda (bundle-name)))
    (localized-template (lambda (package-name message-template-name)))
    )

   ;; SRFI 30
   ("Nested Multi-line Comments"
    )

   ;; SRFI 31
   ("A special form for recursive evaluation"
    (rec (syntax (name body \.\.\.) procedure)))

   ()

   ()

   ;; SRFI 34
   ("Exception Handling for Programs"
    (guard (syntax (clauses \.\.\.)))
    (raise (lambda (obj)))
    )

   ;; SRFI 35
   ("Conditions"
    (make-condition-type (lambda (id parent field-name-list)))
    (condition-type? (lambda (obj)))
    (make-condition (lambda (condition-type)))
    (condition? (lambda (obj)))
    (condition-has-type? (lambda (condition condition-type)))
    (condition-ref (lambda (condition field-name)))
    (make-compound-condition (lambda (condition \.\.\.)))
    (extract-condition (lambda (condition condition-type)))
    (define-condition-type (syntax (name parent pred-name fields \.\.\.)))
    (condition (syntax (type-field-binding \.\.\.)))
    )

   ;; SRFI 36
   ("I/O Conditions"
    (&error condition)
    (&i/o-error condition)
    (&i/o-port-error condition)
    (&i/o-read-error condition)
    (&i/o-write-error condition)
    (&i/o-closed-error condition)
    (&i/o-filename-error condition)
    (&i/o-malformed-filename-error condition)
    (&i/o-file-protection-error condition)
    (&i/o-file-is-read-only-error condition)
    (&i/o-file-already-exists-error condition)
    (&i/o-no-such-file-error condition)
    )

   ;; SRFI 37
   ("args-fold: a program argument processor"
    (args-fold
     (arg-list option-list unrecognized-option-proc operand-proc seed \.\.\.))
    (option-processor (lambda (option name arg seeds \.\.\.)))
    (operand-processor (lambda (operand seeds \.\.\.)))
    (option (lambda (name-list required-arg? optional-arg? option-proc)))
    (option-names (lambda (option)))
    (option-required-arg? (lambda (option)))
    (option-optional-arg? (lambda (option)))
    (option-processor (lambda (option)))
    )

   ;; SRFI 38
   ("External Representation for Data With Shared Structure"
    (write-with-shared-structure (lambda (obj :optional port optarg)))
    (read-with-shared-structure (lambda (:optional port)))
    )

   ;; SRFI 39
   ("Parameter objects"
    (make-parameter (lambda (init-value :optional converter)))
    (parameterize (syntax (bindings body \.\.\.))))

   ;; SRFI 40
   ("A Library of Streams"
    (stream-null stream)
    (stream-cons (syntax (obj stream)))
    (stream? (lambda (obj)))
    (stream-null? (lambda (obj)))
    (stream-pair? (lambda (obj)))
    (stream-car (lambda (stream)))
    (stream-cdr (lambda (stream)))
    (stream-delay (syntax (expr)))
    (stream (lambda (obj \.\.\.)))
    (stream-unfoldn (lambda (generator-proc seed n)))
    (stream-map (lambda (proc stream \.\.\.)))
    (stream-for-each (lambda (proc stream \.\.\.) undefined))
    (stream-filter (lambda (pred stream)))
    )

   ()

   ;; SRFI 42
   ("Eager Comprehensions"
    (list-ec (syntax))
    (append-ec (syntax))
    (sum-ec (syntax))
    (min-ec (syntax))
    (max-ec (syntax))
    (any?-ec (syntax))
    (every?-ec (syntax))
    (first-ec (syntax))
    (do-ec (syntax))
    (fold-ec (syntax))
    (fold3-ec (syntax))
    (:list (syntax () undefined))
    (:string (syntax () undefined))
    (:vector (syntax () undefined))
    (:integers (syntax () undefined))
    (:range (syntax () undefined))
    (:real-range (syntax () undefined))
    (:char-range (syntax () undefined))
    (:port (syntax () undefined))
    (:do (syntax () undefined))
    (:let (syntax () undefined))
    (:parallel (syntax () undefined))
    (:while (syntax () undefined))
    (:until (syntax () undefined))
    )

   ;; SRFI 43
   ("Vector Library"
    (vector-unfold (f length initial-seed \.\.\.))
    (vector-unfold-right (lambda (f length initial-seed \.\.\.)))
    (vector-tabulate (lambda (f size)))
    (vector-copy (lambda (vec :optional start end fill)))
    (vector-reverse-copy (lambda (vec :optional start end)))
    (vector-append (lambda (vec \.\.\.)))
    (vector-concatenate (lambda (vector-list)))
    (vector-empty? (lambda (obj)))
    (vector= (lambda (eq-proc vec \.\.\.)))
    (vector-fold (lambda (kons knil vec \.\.\.)))
    (vector-fold-right (lambda (kons knil vec \.\.\.)))
    (vector-map (lambda (f vec \.\.\.)))
    (vector-map! (lambda (f vec \.\.\.)))
    (vector-for-each (lambda (f vec \.\.\.) undefined))
    (vector-count (lambda (pred vec \.\.\.)))
    (vector-index (lambda (pred vec \.\.\.)))
    (vector-index-right (lambda (pred vec \.\.\.)))
    (vector-skip (lambda (pred vec \.\.\.)))
    (vector-skip-right (lambda (pred vec \.\.\.)))
    (vector-binary-search (lambda (vec value cmp-proc)))
    (vector-any (lambda (pred vec \.\.\.)))
    (vector-every (lambda (pred vec \.\.\.)))
    (vector-swap! (lambda (vec i j) undefined))
    (vector-reverse! (lambda (vec :optional start end) undefined))
    (vector-copy! (lambda (target-vec t-start source-vec :optional start end) undefined))
    (vector-reverse-copy! (lambda (target-vec t-start source-vec :optional start end) undefined))
    (reverse-vector-to-list (lambda (vec :optional start end)))
    (reverse-list-to-vector (lambda (list)))
    )

   ;; SRFI 44
   ("Collections"
    )

   ;; SRFI 45
   ("Primitives for expressing iterative lazy algorithms"
    (delay (syntax (expr)))
    (lazy (syntax (expr)))
    (force (lambda (promise)))
    (eager (lambda (promise)))
    )

   ;; SRFI 46
   ("Basic Syntax-rules Extensions"
    (syntax-rules (syntax () undefined)))

   ;; SRFI 47
   ("Array"
    (make-array (lambda (prototype k \.\.\.)))
    (ac64 (lambda (:optional z)))
    (ac32 (lambda (:optional z)))
    (ar64 (lambda (:optional x1)))
    (ar32 (lambda (:optional x1)))
    (as64 (lambda (:optional n)))
    (as32 (lambda (:optional n)))
    (as16 (lambda (:optional n)))
    (as8 (lambda (:optional n)))
    (au64 (lambda (:optional n)))
    (au32 (lambda (:optional n)))
    (au16 (lambda (:optional n)))
    (au8 (lambda (:optional n)))
    (at1 (lambda (:optional bool)))
    (make-shared-array (lambda (array mapper k \.\.\.)))
    (array-rank (lambda (obj)))
    (array-dimensions (lambda (array)))
    (array-in-bounds? (lambda (array k \.\.\.)))
    (array-ref (lambda (array k \.\.\.)))
    (array-set! (lambda (array obj k \.\.\.)))
    )

   ;; SRFI 48
   ("Intermediate Format Strings"
    (format (lambda (port-or-boolean format-string arg \.\.\.))))

   ;; SRFI 49
   ("Indentation-sensitive syntax"
    )

   ()

   ;; SRFI 51
   ("Handling rest list"
    (rest-values (lambda (caller rest-list :optional args-number-limit default)))
    (arg-and (syntax))
    (arg-ands (syntax))
    (err-and (syntax))
    (err-ands (syntax))
    (arg-or (syntax))
    (arg-ors (syntax))
    (err-or (syntax))
    (err-ors (syntax))
    )

   ()

   ()

   ;; SRFI 54
   ("Formatting"
    (cat (lambda (obj \.\.\.))))

   ;; SRFI 55
   ("require-extension"
    (require-extension (syntax)))

   ()

   ;; SRFI 57
   ("Records"
    (define-record-type (syntax))
    (define-record-scheme (syntax))
    (record-update (syntax))
    (record-update! (syntax))
    (record-compose (syntax)))

   ;; SRFI 58
   ("Array Notation"
    )

   ;; SRFI 59
   ("Vicinity"
    (program-vicinity (lambda ()))
    (library-vicinity (lambda ()))
    (implementation-vicinity (lambda ()))
    (user-vicinity (lambda ()))
    (home-vicinity (lambda ()))
    (in-vicinity (lambda (vicinity filename)))
    (sub-vicinity (lambda (vicinity name)))
    (make-vicinity (lambda (dirname)))
    (path-vicinity (lambda (path)))
    (vicinity:suffix? (lambda (ch)))
    )

   ;; SRFI 60
   ("Integers as Bits"
    (bitwise-and (lambda (n \.\.\.) int))
    (bitwise-ior (lambda (n \.\.\.) int))
    (bitwise-xor (lambda (n \.\.\.) int))
    (bitwise-not (lambda (n) int))
    (bitwise-if (lambda (mask n m) int))
    (any-bits-set? (lambda (n m) bool))
    (bit-count (lambda (n) int))
    (integer-length (lambda (n) int))
    (first-bit-set (lambda (n) int))
    (bit-set? (lambda (i n) bool))
    (copy-bit (lambda (index n bool) int))
    (bit-field (lambda (n start end) int))
    (copy-bit-field (lambda (to-int from-int start end) int))
    (arithmetic-shift (lambda (n count) int))
    (rotate-bit-field (lambda (n count start end) int))
    (reverse-bit-field (lambda (n start end) int))
    (integer->list (lambda (k :optional len) list))
    (list->integer (lambda (list) int))
    )

   ;; SRFI 61
   ("A more general cond clause"
    (cond (syntax)))

   ;; SRFI 62
   ("S-expression comments"
    )

   ;; SRFI 63
   ("Homogeneous and Heterogeneous Arrays"
    )

   ;; SRFI 64
   ("A Scheme API for test suites"
    (test-assert (syntax))
    (test-eqv (syntax))
    (test-equal (syntax))
    (test-eq (syntax))
    (test-approximate (syntax))
    (test-error (syntax))
    (test-read-eval-string (lambda (string)))
    (test-begin (syntax (suite-name :optional count)))
    (test-end (syntax (suite-name)))
    (test-group (syntax (suite-name decl-or-expr \.\.\.)))
    (test-group-with-cleanup (syntax (suite-name decl-or-expr \.\.\.)))
    (test-match-name (lambda (name)))
    (test-match-nth (lambda (n :optional count)))
    (test-match-any (lambda (specifier \.\.\.)))
    (test-match-all (lambda (specifier \.\.\.)))
    (test-skip (syntax (specifier)))
    (test-expect-fail (syntax (specifier)))
    (test-runner? (lambda (obj)))
    (test-runner-current (lambda (:optional runner)))
    (test-runner-get (lambda ()))
    (test-runner-simple (lambda ()))
    (test-runner-null (lambda ()))
    (test-runner-create (lambda ()))
    (test-runner-factory (lambda (:optional factory)))
    (test-apply (syntax (runner specifier \.\.\.)))
    (test-with-runner (syntax (runner decl-or-expr \.\.\.)))
    (test-result-kind (lambda (:optional runner)))
    (test-passed? (lambda (:optional runner)))
    (test-result-ref (lambda (runner prop-name (:optional default))))
    (test-result-set! (lambda (runner prop-name value)))
    (test-result-remove (lambda (runner prop-name)))
    (test-result-clear (lambda (runner)))
    (test-result-alist (lambda (runner)))
    (test-runner-on-test-begin (lambda (runner :optional proc)))
    (test-runner-on-test-begin! (lambda (runner :optional proc)))
    (test-runner-on-test-end (lambda (runner :optional proc)))
    (test-runner-on-test-end! (lambda (runner :optional proc)))
    (test-runner-on-group-begin (lambda (runner :optional proc)))
    (test-runner-on-group-begin! (lambda (runner :optional proc)))
    (test-runner-on-group-end (lambda (runner :optional proc)))
    (test-runner-on-group-end! (lambda (runner :optional proc)))
    (test-runner-on-bad-count (lambda (runner :optional proc)))
    (test-runner-on-bad-count! (lambda (runner :optional proc)))
    (test-runner-on-bad-end-name (lambda (runner :optional proc)))
    (test-runner-on-bad-end-name! (lambda (runner :optional proc)))
    (test-runner-on-final (lambda (runner :optional proc)))
    (test-runner-on-final! (lambda (runner :optional proc)))
    (test-runner-pass-count (lambda (runner)))
    (test-runner-fail-count (lambda (runner)))
    (test-runner-xpass-count (lambda (runner)))
    (test-runner-skip-count (lambda (runner)))
    (test-runner-test-name (lambda (runner)))
    (test-runner-group-path (lambda (runner)))
    (test-runner-group-stack (lambda (runner)))
    (test-runner-aux-value (lambda (runner)))
    (test-runner-aux-value! (lambda (runner)))
    (test-runner-reset (lambda (runner)))
    )

   ()

   ;; SRFI 66
   ("Octet Vectors"
    (make-u8vector (lambda (len n)))
    (u8vector (lambda (n \.\.\.)))
    (u8vector->list (lambda (u8vector)))
    (list->u8vector (lambda (octet-list)))
    (u8vector-length u8vector)
    (u8vector-ref (lambda (u8vector k)))
    (u8vector-set! (lambda (u8vector k n)))
    (u8vector=? (lambda (u8vector-1 u8vector-2)))
    (u8vector-compare (lambda (u8vector-1 u8vector-2)))
    (u8vector-copy! (lambda (source source-start target target-start n)))
    (u8vector-copy (lambda (u8vector)))
    )

   ;; SRFI 67
   ("Compare Procedures"
    )

   ()

   ;; SRFI 69
   ("Basic hash tables"
    (alist->hash-table (lambda (alist) hash-table))
    (hash (lambda (obj :optional n) int))
    (hash-by-identity (lambda (obj :optional n) int))
    (hash-table->alist (lambda (hash-table) alist))
    (hash-table-copy (lambda (hash-table) hash-table))
    (hash-table-delete! (lambda (hash-table key) undefined))
    (hash-table-equivalence-function (lambda (hash-table) pred))
    (hash-table-exists? (lambda (hash-table key) bool))
    (hash-table-fold (lambda (hash-table f init-value)))
    (hash-table-hash-function (lambda (hash-table) f))
    (hash-table-keys (lambda (hash-table) list))
    (hash-table-merge! (lambda (hash-table1 hash-table2) undefined))
    (hash-table-ref (lambda (hash-table key :optional thunk)))
    (hash-table-ref/default (lambda (hash-table key default)))
    (hash-table-remove! (lambda (hash-table proc) undefined))
    (hash-table-set! (lambda (hash-table key value) undefined))
    (hash-table-size (lambda (hash-table) n))
    (hash-table-update! (lambda (hash-table key proc :optional thunk) undefined))
    (hash-table-update!/default (lambda (hash-table key proc default) undefined))
    (hash-table-values (lambda (hash-table) list))
    (hash-table-walk (lambda (hash-table proc) undefined))
    (hash-table? (lambda (obj) bool))
    (make-hash-table (lambda (:optional eq-fn hash-fn) hash-table))
    (string-ci-hash (lambda (str :optional n) n))
    (string-hash (lambda (str1 :optional n) n))
    )

   ;; SRFI 70
   ("Numbers"
    )

   ;; SRFI 71
   ("LET-syntax for multiple values"
    )

   ;; SRFI 72
   ("Simple hygienic macros"
    )

   ()

   ;; SRFI 74
   ("Octet-Addressed Binary Blocks"
    )

   ])

;; another big table generate from texi file
(defconst *gosh-documented-exports*
  '(
    (E2BIG integer)
    (EACCES integer)
    (EADDRINUSE integer)
    (EADDRNOTAVAIL integer)
    (EADV integer)
    (EAFNOSUPPORT integer)
    (EAGAIN integer)
    (EALREADY integer)
    (EBADE integer)
    (EBADF integer)
    (EBADFD integer)
    (EBADMSG integer)
    (EBADR integer)
    (EBADRQC integer)
    (EBADSLT integer)
    (EBFONT integer)
    (EBUSY integer)
    (ECANCELED integer)
    (ECHILD integer)
    (ECHRNG integer)
    (ECOMM integer)
    (ECONNABORTED integer)
    (ECONNREFUSED integer)
    (ECONNRESET integer)
    (EDEADLK integer)
    (EDEADLOCK integer)
    (EDESTADDRREQ integer)
    (EDOM integer)
    (EDOTDOT integer)
    (EDQUOT integer)
    (EEXIST integer)
    (EFAULT integer)
    (EFBIG integer)
    (EHOSTDOWN integer)
    (EHOSTUNREACH integer)
    (EIDRM integer)
    (EILSEQ integer)
    (EINPROGRESS integer)
    (EINTR integer)
    (EINVAL integer)
    (EIO integer)
    (EISCONN integer)
    (EISDIR integer)
    (EISNAM integer)
    (EKEYEXPIRED integer)
    (EKEYREJECTED integer)
    (EKEYREVOKED integer)
    (EL2HLT integer)
    (EL2NSYNC integer)
    (EL3HLT integer)
    (EL3RST integer)
    (ELIBACC integer)
    (ELIBBAD integer)
    (ELIBEXEC integer)
    (ELIBMAX integer)
    (ELIBSCN integer)
    (ELNRNG integer)
    (ELOOP integer)
    (EMEDIUMTYPE integer)
    (EMFILE integer)
    (EMLINK integer)
    (EMSGSIZE integer)
    (EMULTIHOP integer)
    (ENAMETOOLONG integer)
    (ENAVAIL integer)
    (ENETDOWN integer)
    (ENETRESET integer)
    (ENETUNREACH integer)
    (ENFILE integer)
    (ENOANO integer)
    (ENOBUFS integer)
    (ENOCSI integer)
    (ENODATA integer)
    (ENODEV integer)
    (ENOENT integer)
    (ENOEXEC integer)
    (ENOKEY integer)
    (ENOLCK integer)
    (ENOLINK integer)
    (ENOMEDIUM integer)
    (ENOMEM integer)
    (ENOMSG integer)
    (ENONET integer)
    (ENOPKG integer)
    (ENOPROTOOPT integer)
    (ENOSPC integer)
    (ENOSR integer)
    (ENOSTR integer)
    (ENOSYS integer)
    (ENOTBLK integer)
    (ENOTCONN integer)
    (ENOTDIR integer)
    (ENOTEMPTY integer)
    (ENOTNAM integer)
    (ENOTSOCK integer)
    (ENOTTY integer)
    (ENOTUNIQ integer)
    (ENXIO integer)
    (EOPNOTSUPP integer)
    (EOVERFLOW integer)
    (EPERM integer)
    (EPFNOSUPPORT integer)
    (EPIPE integer)
    (EPROTO integer)
    (EPROTONOSUPPORT integer)
    (EPROTOTYPE integer)
    (ERANGE integer)
    (EREMCHG integer)
    (EREMOTE integer)
    (EREMOTEIO integer)
    (ERESTART integer)
    (EROFS integer)
    (ESHUTDOWN integer)
    (ESOCKTNOSUPPORT integer)
    (ESPIPE integer)
    (ESRCH integer)
    (ESRMNT integer)
    (ESTALE integer)
    (ESTRPIPE integer)
    (ETIME integer)
    (ETIMEDOUT integer)
    (ETOOMANYREFS integer)
    (ETXTBSY integer)
    (EUCLEAN integer)
    (EUNATCH integer)
    (EUSERS integer)
    (EWOULDBLOCK integer)
    (EXDEV integer)
    (EXFULL integer)
    (F_OK integer)
    (LC_ALL integer)
    (LC_COLLATE integer)
    (LC_CTYPE integer)
    (LC_MONETARY integer)
    (LC_NUMERIC integer)
    (LC_TIME integer)
    (RAND_MAX integer)
    (R_OK integer)
    (SEEK_CUR integer)
    (SEEK_END integer)
    (SEEK_SET integer)
    (SIGABRT integer)
    (SIGALRM integer)
    (SIGBUS integer)
    (SIGCHLD integer)
    (SIGCONT integer)
    (SIGFPE integer)
    (SIGHUP integer)
    (SIGILL integer)
    (SIGINT integer)
    (SIGIO integer)
    (SIGIOT integer)
    (SIGKILL integer)
    (SIGPIPE integer)
    (SIGPOLL integer)
    (SIGPROF integer)
    (SIGPWR integer)
    (SIGQUIT integer)
    (SIGSEGV integer)
    (SIGSTKFLT integer)
    (SIGSTOP integer)
    (SIGTERM integer)
    (SIGTRAP integer)
    (SIGTSTP integer)
    (SIGTTIN integer)
    (SIGTTOU integer)
    (SIGURG integer)
    (SIGUSR1 integer)
    (SIGUSR2 integer)
    (SIGVTALRM integer)
    (SIGWINCH integer)
    (SIGXCPU integer)
    (SIGXFSZ integer)
    (SIG_BLOCK integer)
    (SIG_SETMASK integer)
    (SIG_UNBLOCK integer)
    (W_OK integer)
    (X_OK integer)
    (quote (syntax (datum)))
    (lambda (syntax (formals body \.\.\.)))
    (^ (syntax (formals body \.\.\.)))
    (^c (syntax (body \.\.\.)))
    (cut (syntax (expr-or-slot expr-or-slot2 \.\.\.)))
    (cute (syntax (expr-or-slot expr-or-slot2 \.\.\.)))
    (case-lambda (syntax (clause \.\.\.)))
    (set! (syntax (symbol expression)))
    (set! (syntax (\(proc\ arg\ \.\.\.\) expression)))
    (set!-values (syntax (\(var\ \.\.\.\) expr)))
    (setter (lambda (proc)))
    (has-setter\? (lambda (proc)))
    (getter-with-setter (lambda (get set)))
    (push! (syntax (place item)))
    (pop! (syntax (place)))
    (inc! (syntax (place :optional delta)))
    (dec! (syntax (place :optional delta)))
    (update! (syntax (place proc)))
    (if (syntax (test consequent alternative)))
    (if (syntax (test consequent)))
    (cond (syntax (clause1 clause2 \.\.\.)))
    (case (syntax (key clause1 clause2 \.\.\.)))
    (and (syntax (test \.\.\.)))
    (or (syntax (test \.\.\.)))
    (when (syntax (test body \.\.\.)))
    (unless (syntax (test body \.\.\.)))
    (let (syntax (\(\(var\ expr\)\ \.\.\.\) body \.\.\.)))
    (let* (syntax (\(\(var\ expr\)\ \.\.\.\) body \.\.\.)))
    (letrec (syntax (\(\(var\ expr\)\ \.\.\.\) body \.\.\.)))
    (let1 (syntax (var expr body \.\.\.)))
    (if-let1 (syntax (var expr then)))
    (if-let1 (syntax (var expr then else)))
    (rlet1 (syntax (var expr body \.\.\.)))
    (and-let* (syntax (\(binding\ \.\.\.\) body \.\.\.)))
    (fluid-let (syntax (\(\(var\ val\)\ \.\.\.\) body \.\.\.)))
    (receive (syntax (formals expression body \.\.\.)))
    (rec (syntax (var expr)))
    (rec (syntax (\(name\ \.\ vars\) expr \.\.\.)))
    (begin (syntax (form \.\.\.)))
    (begin0 (syntax (exp0 exp1 \.\.\.)))
    (do (syntax (\(\(variable\ init\ \[step\]\)\ \.\.\.\) \(test\ expr\ \.\.\.\) body \.\.\.)))
    (let (syntax (name bindings body \.\.\.)))
    (dotimes (syntax (\(variable\ limit\ \[result\]\) body \.\.\.)))
    (dolist (syntax (\(variable\ lexpr\ \[result\]\) body \.\.\.)))
    (while (syntax (expr body \.\.\.)))
    (while (syntax (expr \'=>\' var body \.\.\.)))
    (while (syntax (expr guard \'=>\' var body \.\.\.)))
    (until (syntax (expr body \.\.\.)))
    (until (syntax (expr guard \'=>\' var body \.\.\.)))
    (quasiquote (syntax (template)))
    (unquote (syntax (datum)))
    (unquote-splicing (syntax (datum)))
    (define (syntax (variable expression)))
    (define (syntax (\(variable\ \.\ formals\) body \.\.\.)))
    (define-values (syntax (\(var\ \.\.\.\) expr)))
    (define-constant (syntax (variable expression)))
    (define-constant (syntax (\(variable\ \.\ formals\) body \.\.\.)))
    (define-in-module (syntax (module variable expression)))
    (define-in-module (syntax (module \(variable\ \.\ formals\) body \.\.\.)))
    (define-module (syntax (name body \.\.\.)))
    (select-module (syntax (name)))
    (with-module (syntax (name body \.\.\.)))
    (current-module (syntax nil))
    (export (syntax (symbol \.\.\.)))
    (export-all (syntax nil))
    (import (syntax (import-spec \.\.\.)))
    (use (syntax (name :key (only) (except) (rename) (prefix))))
    (extend (syntax (module-name \.\.\.)))
    (module\? (lambda (obj)))
    (find-module (lambda (name)))
    (make-module (lambda (name :key (if-exists))))
    (all-modules (lambda nil))
    (module-name (lambda (module)))
    (module-imports (lambda (module)))
    (module-exports (lambda (module)))
    (module-table (lambda (module)))
    (module-parents (lambda (module)))
    (module-precedence-list (lambda (module)))
    (global-variable-bound\? (lambda (module symbol)))
    (global-variable-ref (lambda (module symbol :optional default)))
    (module-name->path (lambda (symbol)))
    (path->module-name (lambda (string)))
    (define-syntax (syntax (name transformer-spec)))
    (let-syntax (syntax (\(\(name\ transformer-spec\)\ \.\.\.\) body)))
    (letrec-syntax (syntax (\(\(name\ transformer-spec\)\ \.\.\.\) body)))
    (syntax-rules (syntax (literals clause1 clause2 \.\.\.)))
    (define-macro (syntax (name procedure)))
    (define-macro (syntax (\(name\ \.\ formals\) body \.\.\.)))
    (macroexpand (lambda (form)))
    (macroexpand-1 (lambda (form)))
    (%macroexpand (syntax (form)))
    (%macroexpand-1 (syntax (form)))
    (syntax-error (syntax (msg arg \.\.\.)))
    (syntax-errorf (syntax (fmt arg \.\.\.)))
    (unwrap-syntax (lambda (form)))
    (eq\? (lambda (obj1 obj2)))
    (eqv\? (lambda (obj1 obj2)))
    (equal\? (lambda (obj1 obj2)))
    (number\? (lambda (obj)))
    (complex\? (lambda (obj)))
    (real\? (lambda (obj)))
    (rational\? (lambda (obj)))
    (integer\? (lambda (obj)))
    (real-valued\? (lambda (obj)))
    (rational-valued\? (lambda (obj)))
    (integer-valued\? (lambda (obj)))
    (exact\? (lambda (obj)))
    (inexact\? (lambda (obj)))
    (zero\? (lambda (z)))
    (positive\? (lambda (x)))
    (negative\? (lambda (x)))
    (finite\? (lambda (z)))
    (infinite\? (lambda (z)))
    (nan\? (lambda (z)))
    (odd\? (lambda (n)))
    (even\? (lambda (n)))
    (fixnum\? (lambda (n)))
    (bignum\? (lambda (n)))
    (= (lambda (z1 z2 z3 \.\.\.)))
    (< (lambda (x1 x2 x3 \.\.\.)))
    (<= (lambda (x1 x2 x3 \.\.\.)))
    (> (lambda (x1 x2 x3 \.\.\.)))
    (>= (lambda (x1 x2 x3 \.\.\.)))
    (max (lambda (x1 x2 \.\.\.)))
    (min (lambda (x1 x2 \.\.\.)))
    (min&max (lambda (x1 x2 \.\.\.)))
    (+ (lambda (z \.\.\.)))
    (* (lambda (z \.\.\.)))
    (- (lambda (z1 z2 \.\.\.)))
    (/ (lambda (z1 z2 \.\.\.)))
    (\0 (lambda (z \.\.\.)))
    (*\\\. (lambda (z \.\.\.)))
    (\0 (lambda (z1 z2 \.\.\.)))
    (/\\\. (lambda (z1 z2 \.\.\.)))
    (abs (lambda (z)))
    (quotient (lambda (n1 n2)))
    (remainder (lambda (n1 n2)))
    (modulo (lambda (n1 n2)))
    (quotient&remainder (lambda (n1 n2)))
    (div (lambda (x y)))
    (mod (lambda (x y)))
    (div-and-mod (lambda (x y)))
    (div0 (lambda (x y)))
    (mod0 (lambda (x y)))
    (div0-and-mod0 (lambda (x y)))
    (gcd (lambda (n \.\.\.)))
    (lcm (lambda (n \.\.\.)))
    (numerator (lambda (q)))
    (denominator (lambda (q)))
    (floor (lambda (x)))
    (ceiling (lambda (x)))
    (truncate (lambda (x)))
    (round (lambda (x)))
    (floor->exact (lambda (x)))
    (ceiling->exact (lambda (x)))
    (truncate->exact (lambda (x)))
    (round->exact (lambda (x)))
    (clamp (lambda (x :optional min max)))
    (exp (lambda (z)))
    (log (lambda (z)))
    (log (lambda (z1 z2)))
    (sin (lambda (z)))
    (cos (lambda (z)))
    (tan (lambda (z)))
    (asin (lambda (z)))
    (acos (lambda (z)))
    (atan (lambda (z)))
    (atan (lambda (y x)))
    (sinh (lambda (z)))
    (cosh (lambda (z)))
    (tanh (lambda (z)))
    (asinh (lambda (z)))
    (acosh (lambda (z)))
    (atanh (lambda (z)))
    (sqrt (lambda (z)))
    (exact-integer-sqrt (lambda (k)))
    (expt (lambda (z1 z2)))
    (fixnum-width (lambda nil))
    (greatest-fixnum (lambda nil))
    (least-fixnum (lambda nil))
    (make-rectangular (lambda (x1 x2)))
    (make-polar (lambda (x1 x2)))
    (real-part (lambda (z)))
    (imag-part (lambda (z)))
    (magnitude (lambda (z)))
    (angle (lambda (z)))
    (decode-float (lambda (x)))
    (fmod (lambda (x y)))
    (modf (lambda (x)))
    (frexp (lambda (x)))
    (ldexp (lambda (x n)))
    (exact (lambda (z)))
    (inexact (lambda (z)))
    (exact->inexact (lambda (z)))
    (inexact->exact (lambda (z)))
    (number->string (lambda (z :optional radix use-upper\?)))
    (string->number (lambda (string :optional radix)))
    (ash (lambda (n count)))
    (logand (lambda (n1 n2 \.\.\.)))
    (logior (lambda (n1 n2 \.\.\.)))
    (logxor (lambda (n1 n2 \.\.\.)))
    (lognot (lambda (n)))
    (logtest (lambda (n1 n2 \.\.\.)))
    (logbit\? (lambda (index n)))
    (bit-field (lambda (n start end)))
    (copy-bit (lambda (index n bit)))
    (copy-bit-field (lambda (n start end from)))
    (logcount (lambda (n)))
    (integer-length (lambda (n)))
    (native-endian (lambda nil))
    (not (lambda (obj)))
    (boolean\? (lambda (obj)))
    (boolean (lambda (obj)))
    (undefined\? (lambda (obj)))
    (undefined (lambda nil))
    (pair\? (lambda (obj)))
    (null\? (lambda (obj)))
    (list\? (lambda (obj)))
    (cons (lambda (obj1 obj2)))
    (acons (lambda (obj1 obj2 obj3)))
    (make-list (lambda (len :optional fill)))
    (list (lambda (obj \.\.\.)))
    (list* (lambda (obj1 obj2 \.\.\.)))
    (list-copy (lambda (list)))
    (car (lambda (pair)))
    (cdr (lambda (pair)))
    (set-car! (lambda (pair obj)))
    (set-cdr! (lambda (pair obj)))
    (caar (lambda (pair)))
    (cadr (lambda (pair)))
    (cdddar (lambda (pair)))
    (cddddr (lambda (pair)))
    (length (lambda (list)))
    (list-tail (lambda (list k :optional fallback)))
    (list-ref (lambda (list k :optional fallback)))
    (last-pair (lambda (list)))
    (append (lambda (list \.\.\.)))
    (append! (lambda (list \.\.\.)))
    (reverse (lambda (list)))
    (reverse! (lambda (list)))
    (memq (lambda (obj list)))
    (memv (lambda (obj list)))
    (member (lambda (obj list)))
    (assq (lambda (obj list)))
    (assv (lambda (obj list)))
    (assoc (lambda (obj list)))
    (symbol\? (lambda (obj)))
    (symbol-interned\? (lambda (symbol)))
    (symbol->string (lambda (symbol)))
    (string->symbol (lambda (string)))
    (string->uninterned-symbol (lambda (string)))
    (gensym (lambda (:optional prefix)))
    (symbol-sans-prefix (lambda (symbol prefix)))
    (keyword\? (lambda (obj)))
    (make-keyword (lambda (name)))
    (keyword->string (lambda (keyword)))
    (get-keyword (lambda (key kv-list :optional fallback)))
    (get-keyword* (syntax (key kv-list :optional fallback)))
    (delete-keyword (lambda (key kv-list)))
    (delete-keyword! (lambda (key kv-list)))
    (delete-keywords (lambda (keys kv-list)))
    (delete-keywords! (lambda (keys kv-list)))
    (identifier\? (lambda (obj)))
    (identifier->symbol (lambda (identifier)))
    (char\? (lambda (obj)))
    (char=\? (lambda (char1 char2)))
    (char<\? (lambda (char1 char2)))
    (char<=\? (lambda (char1 char2)))
    (char>\? (lambda (char1 char2)))
    (char>=\? (lambda (char1 char2)))
    (char-ci=\? (lambda (char1 char2)))
    (char-ci<\? (lambda (char1 char2)))
    (char-ci<=\? (lambda (char1 char2)))
    (char-ci>\? (lambda (char1 char2)))
    (char-ci>=\? (lambda (char1 char2)))
    (char-alphabetic\? (lambda (char)))
    (char-numeric\? (lambda (char)))
    (char-whitespace\? (lambda (char)))
    (char-upper-case\? (lambda (char)))
    (char-lower-case\? (lambda (char)))
    (char->integer (lambda (char)))
    (integer->char (lambda (n)))
    (char->ucs (lambda (char)))
    (ucs->char (lambda (n)))
    (char-upcase (lambda (char)))
    (char-downcase (lambda (char)))
    (digit->integer (lambda (char :optional \(radix\ 10\))))
    (integer->digit (lambda (integer :optional \(radix\ 10\))))
    (gauche-character-encoding (lambda nil))
    (supported-character-encodings (lambda nil))
    (char-set\? (lambda (obj)))
    (char-set-contains\? (lambda (char-set char)))
    (char-set (lambda (char \.\.\.)))
    (char-set-copy (lambda (char-set)))
    (string\? (lambda (obj)))
    (string-immutable\? (lambda (obj)))
    (string-incomplete\? (lambda (obj)))
    (make-string (lambda (k :optional char)))
    (make-byte-string (lambda (k :optional byte)))
    (string (lambda (char \.\.\.)))
    (string-length (lambda (string)))
    (string-size (lambda (string)))
    (string-ref (lambda (cstring k :optional fallback)))
    (string-byte-ref (lambda (string k)))
    (string-set! (lambda (string k char)))
    (string-byte-set! (lambda (string k byte)))
    (string=\? (lambda (string1 string2)))
    (string-ci=\? (lambda (string1 string2)))
    (string<\? (lambda (string1 string2)))
    (string<=\? (lambda (string1 string2)))
    (string>\? (lambda (string1 string2)))
    (string>=\? (lambda (string1 string2)))
    (string-ci<\? (lambda (string1 string2)))
    (string-ci<=\? (lambda (string1 string2)))
    (string-ci>\? (lambda (string1 string2)))
    (string-ci>=\? (lambda (string1 string2)))
    (substring (lambda (string start end)))
    (string-append (lambda (string \.\.\.)))
    (string->list (lambda (string :optional start end)))
    (list->string (lambda (list)))
    (string-copy (lambda (string :optional start end)))
    (string-fill! (lambda (string char :optional start end)))
    (string-join (lambda (strs :optional delim grammer)))
    (string-scan (lambda (string item :optional return)))
    (string-split (lambda (string splitter)))
    (string-incomplete->complete (lambda (str :optional handling)))
    (string->regexp (lambda (string :key (case-fold))))
    (regexp\? (lambda (obj)))
    (regexp->string (lambda (regexp)))
    (rxmatch (lambda (regexp string)))
    (rxmatch-start (lambda (match :optional \(i\ 0\))))
    (rxmatch-end (lambda (match :optional \(i\ 0\))))
    (rxmatch-substring (lambda (match :optional \(i\ 0\))))
    (rxmatch-num-matches (lambda (match)))
    (rxmatch-after (lambda (match :optional \(i\ 0\))))
    (rxmatch-before (lambda (match :optional \(i\ 0\))))
    (rxmatch->string (lambda (regexp string :optional selector \.\.\.)))
    (regexp-replace (lambda (regexp string substitution)))
    (regexp-replace-all (lambda (regexp string substitution)))
    (regexp-replace* (lambda (string rx1 sub1 rx2 sub2 \.\.\.)))
    (regexp-replace-all* (lambda (string rx1 sub1 rx2 sub2 \.\.\.)))
    (regexp-quote (lambda (string)))
    (rxmatch-let (syntax (match-expr \(var\ \.\.\.\) form \.\.\.)))
    (rxmatch-if (syntax (match-expr \(var\ \.\.\.\) then-form else-form)))
    (rxmatch-cond (syntax (clause \.\.\.)))
    (rxmatch-case (syntax (string-expr clause \.\.\.)))
    (regexp-parse (lambda (string :key (case-fold))))
    (regexp-optimize (lambda (ast)))
    (regexp-compile (lambda (ast)))
    (regexp-ast (lambda (regexp)))
    (regexp-unparse (lambda (ast :key (\(on-error\ :error\)))))
    (vector\? (lambda (obj)))
    (make-vector (lambda (k :optional fill)))
    (vector (lambda (obj \.\.\.)))
    (vector-length (lambda (vector)))
    (vector-ref (lambda (vector k :optional fallback)))
    (vector-set! (lambda (vector k obj)))
    (vector->list (lambda (vector :optional start end)))
    (list->vector (lambda (list :optional start end)))
    (vector-fill! (lambda (vector fill :optional start end)))
    (vector-copy (lambda (vector :optional start end fill)))
    (make-hash-table (lambda (:optional type)))
    (hash (lambda (obj)))
    (eq-hash (lambda (obj)))
    (eqv-hash (lambda (obj)))
    (hash-table\? (lambda (obj)))
    (hash-table-type (lambda (ht)))
    (hash-table-num-entries (lambda (ht)))
    (hash-table (lambda (type key&value \.\.\.)))
    (hash-table-get (lambda (ht key :optional default)))
    (hash-table-put! (lambda (ht key value)))
    (hash-table-exists\? (lambda (ht key)))
    (hash-table-delete! (lambda (ht key)))
    (hash-table-clear! (lambda (ht)))
    (hash-table-push! (lambda (ht key value)))
    (hash-table-pop! (lambda (ht key :optional default)))
    (hash-table-update! (lambda (ht key proc :optional default)))
    (hash-table-for-each (lambda (ht proc)))
    (hash-table-map (lambda (ht proc)))
    (hash-table-fold (lambda (ht kons knil)))
    (hash-table-keys (lambda (ht)))
    (hash-table-values (lambda (ht)))
    (make-tree-map (lambda (key=\? key<\?)))
    (tree-map-copy (lambda (tree-map)))
    (tree-map-empty\? (lambda (tree-map)))
    (tree-map-num-entries (lambda (tree-map)))
    (tree-map-exists\? (lambda (tree-map key)))
    (tree-map-get (lambda (tree-map key :optional fallback)))
    (tree-map-put! (lambda (tree-map key value)))
    (tree-map-delete! (lambda (tree-map key)))
    (tree-map-clear! (lambda (tree-map)))
    (tree-map-update! (lambda (tree-map key proc :optional fallback)))
    (tree-map-push! (lambda (tree-map key value)))
    (tree-map-pop! (lambda (tree-map key :optional fallback)))
    (tree-map-min (lambda (tree-map)))
    (tree-map-max (lambda (tree-map)))
    (tree-map-pop-min! (lambda (tree-map)))
    (tree-map-pop-max! (lambda (tree-map)))
    (tree-map-fold (lambda (tree-map proc seed)))
    (tree-map-fold-right (lambda (tree-map proc seed)))
    (tree-map-map (lambda (tree-map proc)))
    (tree-map-for-each (lambda (tree-map proc)))
    (tree-map-floor (lambda (tree-map probe :optional fallback-key fallback-value)))
    (tree-map-ceiling (lambda (tree-map probe :optional fallback-key fallback-value)))
    (tree-map-predecessor (lambda (tree-map probe :optional fallback-key fallback-value)))
    (tree-map-successor (lambda (tree-map probe :optional fallback-key fallback-value)))
    (tree-map-floor-key (lambda (tree-map probe :optional fallback-key)))
    (tree-map-ceiling-key (lambda (tree-map probe :optional fallback-key)))
    (tree-map-predecessor-key (lambda (tree-map probe :optional fallback-key)))
    (tree-map-successor-key (lambda (tree-map probe :optional fallback-key)))
    (tree-map-floor-value (lambda (tree-map probe :optional fallback-value)))
    (tree-map-ceiling-value (lambda (tree-map probe :optional fallback-value)))
    (tree-map-predecessor-value (lambda (tree-map probe :optional fallback-value)))
    (tree-map-successor-value (lambda (tree-map probe :optional fallback-value)))
    (tree-map-keys (lambda (tree-map)))
    (tree-map-values (lambda (tree-map)))
    (tree-map->alist (lambda (tree-map)))
    (alist->tree-map (lambda (alist key=\? key<\?)))
    (make-weak-vector (lambda (size)))
    (weak-vector-length (lambda (wvec)))
    (weak-vector-ref (lambda (wvec k &optioal fallback)))
    (weak-vector-set! (lambda (wvec k obj)))
    (procedure\? (lambda (obj)))
    (apply (lambda (proc arg1 \.\.\. args)))
    (~ (lambda (obj key keys \.\.\.)))
    (map (lambda (proc list1 list2 \.\.\.)))
    (for-each (lambda (proc list1 list2 \.\.\.)))
    (pa$ (lambda (proc arg \.\.\.)))
    (apply$ (lambda (proc)))
    (map$ (lambda (proc)))
    (for-each$ (lambda (proc)))
    (count$ (lambda (pred)))
    (fold$ (lambda (kons :optional knil)))
    (fold-right$ (lambda (kons :optional knil)))
    (reduce$ (lambda (f :optional ridentity)))
    (reduce-right$ (lambda (f :optional ridentity)))
    (filter$ (lambda (pred)))
    (remove$ (lambda (pred)))
    (partition$ (lambda (pred)))
    (member$ (lambda (item)))
    (find$ (lambda (pred)))
    (find-tail$ (lambda (pred)))
    (any$ (lambda (pred)))
    (every$ (lambda (pred)))
    (delete$ (lambda (pred)))
    (assoc$ (lambda (item)))
    (\\\.$ (lambda (f \.\.\.)))
    (compose (lambda (f \.\.\.)))
    (complement (lambda (pred)))
    (any-pred (lambda (pred \.\.\.)))
    (every-pred (lambda (pred \.\.\.)))
    (let-optionals* (syntax (restargs \(var-spec\ \.\.\.\) body \.\.\.)))
    (let-optionals* (syntax (restargs \(var-spec\ \.\.\.\ \.\ restvar\) body \.\.\.)))
    (get-optional (syntax (restargs default)))
    (let-keywords (syntax (restarg \(var-spec\ \.\.\.\) body \.\.\.)))
    (let-keywords (syntax (restarg \(var-spec\ \.\.\.\ \.\ restvar\) body \.\.\.)))
    (let-keywords* (syntax (restarg \(var-spec\ \.\.\.\) body \.\.\.)))
    (let-keywords* (syntax (restarg \(var-spec\ \.\.\.\ \.\ restvar\) body \.\.\.)))
    (arity (lambda (proc)))
    (arity-at-least\? (lambda (obj)))
    (arity-at-least-value (lambda (arity-at-least)))
    (procedure-arity-includes\? (lambda (proc k)))
    (call-with-current-continuation (lambda (proc)))
    (call/cc (lambda (proc)))
    (let/cc (syntax (var body \.\.\.)))
    (dynamic-wind (lambda (before thunk after)))
    (values (lambda (obj \.\.\.)))
    (call-with-values (lambda (producer consumer)))
    (values-ref (syntax (mv-expr k)))
    (lazy (syntax (expression)))
    (delay (syntax (expression)))
    (force (lambda (promise)))
    (promise\? (lambda (obj)))
    (error (lambda (string arg \.\.\.)))
    (error (lambda (condition-type keyword-arg \.\.\. string arg \.\.\.)))
    (errorf (lambda (fmt-string arg \.\.\.)))
    (errorf (lambda (condition-type keyword-arg \.\.\. fmt-string arg \.\.\.)))
    (raise (lambda (condition)))
    (guard (syntax (\(var\ clause\ \.\.\.\) body \.\.\.)))
    (unwind-protect (syntax (body cleanup)))
    (with-error-handler (lambda (handler thunk)))
    (current-exception-handler (lambda nil))
    (with-exception-handler (lambda (handler thunk)))
    (define-condition-type (syntax (name supertype predicate field-spec \.\.\.)))
    (condition-type\? (lambda (obj)))
    (make-condition-type (lambda (name parent field-names)))
    (make-condition (lambda (type field-name value \.\.\.)))
    (condition-has-type\? (lambda (obj type)))
    (condition-ref (lambda (condition field-name)))
    (make-compound-condition (lambda (condition0 condition1 \.\.\.)))
    (extract-condition (lambda (condition condition-type)))
    (condition (syntax (type-field-binding \.\.\.)))
    (eval (lambda (expr env)))
    (null-environment (lambda (version)))
    (scheme-report-environment (lambda (version)))
    (interaction-environment (lambda nil))
    (read-eval-print-loop (lambda (:optional reader evaluator printer prompter)))
    (with-port-locking (lambda (port thunk)))
    (port\? (lambda (obj)))
    (input-port\? (lambda (obj)))
    (output-port\? (lambda (obj)))
    (port-closed\? (lambda (port)))
    (current-input-port (lambda nil))
    (current-output-port (lambda nil))
    (current-error-port (lambda nil))
    (standard-input-port (lambda (:optional new-port)))
    (standard-output-port (lambda (:optional new-port)))
    (standard-error-port (lambda (:optional new-port)))
    (with-input-from-port (lambda (port thunk)))
    (with-output-to-port (lambda (port thunk)))
    (with-error-to-port (lambda (port thunk)))
    (with-ports (lambda (iport oport eport thunk)))
    (close-input-port (lambda (port)))
    (close-output-port (lambda (port)))
    (port-type (lambda (port)))
    (port-name (lambda (port)))
    (port-buffering (lambda (port)))
    (port-current-line (lambda (port)))
    (port-file-number (lambda (port)))
    (port-seek (lambda (port offset :optional whence)))
    (port-tell (lambda (port)))
    (copy-port (lambda (src dst :key (\(unit\ 0\)))))
    (open-input-file (lambda (filename :key (if-does-not-exist) (buffering) (element-type) (encoding) (conversion-buffer-size))))
    (open-output-file (lambda (filename :key (if-does-not-exist) (if-exists) (buffering) (element-type) (encoding) (conversion-buffer-size))))
    (call-with-input-file (lambda (string proc :key (if-does-not-exist) (buffering) (element-type) (encoding) (conversion-buffer-size))))
    (call-with-output-file (lambda (string proc :key (if-does-not-exist) (if-exists) (buffering) (element-type) (encoding) (conversion-buffer-size))))
    (with-input-from-file (lambda (string thunk :key (if-does-not-exist) (buffering) (element-type) (encoding) (conversion-buffer-size))))
    (with-output-to-file (lambda (string thunk :key (if-does-not-exist) (if-exists) (buffering) (element-type) (encoding) (conversion-buffer-size))))
    (open-input-fd-port (lambda (fd :key (buffering) (name) (owner\?))))
    (open-output-fd-port (lambda (fd :key (buffering) (name) (owner\?))))
    (port-fd-dup! (lambda (toport fromport)))
    (open-input-string (lambda (string)))
    (get-remaining-input-string (lambda (port)))
    (open-output-string (lambda nil))
    (get-output-string (lambda (port)))
    (call-with-input-string (lambda (string proc)))
    (call-with-output-string (lambda (proc)))
    (with-input-from-string (lambda (string thunk)))
    (with-output-to-string (lambda (thunk)))
    (call-with-string-io (lambda (str proc)))
    (with-string-io (lambda (str thunk)))
    (write-to-string (lambda (obj :optional writer)))
    (read-from-string (lambda (string :optional start end)))
    (open-coding-aware-port (lambda (iport)))
    (read (lambda (:optional iport)))
    (read-with-shared-structure (lambda (:optional iport)))
    (read/ss (lambda (:optional iport)))
    (read-char (lambda (:optional iport)))
    (peek-char (lambda (:optional iport)))
    (read-byte (lambda (:optional iport)))
    (peek-byte (lambda (:optional iport)))
    (read-line (lambda (:optional iport allow-byte-string\?)))
    (read-block (lambda (nbytes :optional iport)))
    (eof-object (lambda nil))
    (eof-object\? (lambda (obj)))
    (char-ready\? (lambda (port)))
    (byte-ready\? (lambda (port)))
    (define-reader-ctor (lambda (tag procedure)))
    (port->string (lambda (port)))
    (port->list (lambda (reader port)))
    (port->string-list (lambda (port)))
    (port->sexp-list (lambda (port)))
    (port-fold (lambda (fn knil reader)))
    (port-fold-right (lambda (fn knil reader)))
    (port-for-each (lambda (fn reader)))
    (port-map (lambda (fn reader)))
    (write (lambda (obj :optional port)))
    (display (lambda (obj :optional port)))
    (write-with-shared-structure (lambda (obj :optional port)))
    (write/ss (lambda (obj :optional port)))
    (write* (lambda (obj :optional port)))
    (print (lambda (expr \.\.\.)))
    (newline (lambda (:optional port)))
    (flush (lambda (:optional port)))
    (flush-all-ports (lambda nil))
    (write-char (lambda (char :optional port)))
    (write-byte (lambda (byte :optional port)))
    (format (lambda (port string arg \.\.\.)))
    (format (lambda (string arg \.\.\.)))
    (load (lambda (file :key (paths))))
    (add-load-path (syntax (path :optional)))
    (load-from-port (lambda (port)))
    (current-load-port (lambda nil))
    (current-load-path (lambda nil))
    (current-load-history (lambda nil))
    (current-load-next (lambda nil))
    (dynamic-load (lambda (file :key (init-function) (export-symbols))))
    (require (syntax (feature)))
    (provide (lambda (feature)))
    (provided\? (lambda (feature)))
    (autoload (syntax (file/module item \.\.\.)))
    (library-fold (lambda (pattern proc seed :key (paths) (strict\?) (allow-duplicates\?))))
    (library-map (lambda (pattern proc :key (paths) (allow-duplicates\?) (strict\?))))
    (library-for-each (lambda (pattern proc :key (paths) (allow-duplicates\?) (strict\?))))
    (library-exists\? (lambda (mod/path :key (paths) (force-search\?) (strict\?))))
    (library-has-module\? (lambda (path module)))
    (compare (lambda (obj1 obj2)))
    (sort (lambda (seq :optional cmpfn)))
    (sort! (lambda (seq :optional cmpfn)))
    (stable-sort (lambda (seq :optional cmpfn)))
    (stable-sort! (lambda (seq :optional cmpfn)))
    (sort-by (lambda (seq key :optional cmpfn)))
    (sort-by! (lambda (seq key :optional cmpfn)))
    (stable-sort-by (lambda (seq key :optional cmpfn)))
    (stable-sort-by! (lambda (seq key :optional cmpfn)))
    (exit (lambda (:optional \(code\ 0\))))
    (exit-handler (lambda (:optional new-handler)))
    (sys-exit (lambda (code)))
    (sys-abort (lambda nil))
    (sys-getenv (lambda (name)))
    (sys-environ (lambda nil))
    (sys-environ->alist (lambda (:optional envlist)))
    (sys-putenv (lambda (name value)))
    (gauche-version (lambda nil))
    (gauche-architecture (lambda nil))
    (gauche-library-directory (lambda nil))
    (gauche-architecture-directory (lambda nil))
    (gauche-site-library-directory (lambda nil))
    (gauche-site-architecture-directory (lambda nil))
    (sys-readdir (lambda (path)))
    (glob (lambda (pattern :key (separator) (folder))))
    (sys-glob (lambda (pattern :key (separator) (folder))))
    (glob-fold (lambda (pattern proc seed :key (separator) (folder))))
    (make-glob-fs-fold (lambda (:key (root-path) (current-path))))
    (sys-remove (lambda (filename)))
    (sys-rename (lambda (old new)))
    (sys-tmpnam (lambda nil))
    (sys-mkstemp (lambda (template)))
    (sys-link (lambda (existing new)))
    (sys-unlink (lambda (pathname)))
    (sys-symlink (lambda (existing new)))
    (sys-readlink (lambda (path)))
    (sys-mkdir (lambda (pathname mode)))
    (sys-rmdir (lambda (pathname)))
    (sys-umask (lambda (:optional mode)))
    (sys-normalize-pathname (lambda (pathname :key (absolute) (expand) (canonicalize))))
    (sys-basename (lambda (pathname)))
    (sys-dirname (lambda (pathname)))
    (sys-realpath (lambda (pathname)))
    (sys-tmpdir (lambda nil))
    (file-exists\? (lambda (path)))
    (file-is-regular\? (lambda (path)))
    (file-is-directory\? (lambda (path)))
    (sys-stat (lambda (path)))
    (sys-fstat (lambda (port-or-fd)))
    (sys-lstat (lambda (path)))
    (sys-stat->mode (lambda (stat)))
    (sys-stat->ino (lambda (stat)))
    (sys-stat->dev (lambda (stat)))
    (sys-stat->rdev (lambda (stat)))
    (sys-stat->nlink (lambda (stat)))
    (sys-stat->size (lambda (stat)))
    (sys-stat->uid (lambda (stat)))
    (sys-stat->gid (lambda (stat)))
    (sys-stat->atime (lambda (stat)))
    (sys-stat->mtime (lambda (stat)))
    (sys-stat->ctime (lambda (stat)))
    (sys-stat->file-type (lambda (stat)))
    (sys-access (lambda (pathname amode)))
    (sys-chmod (lambda (path mode)))
    (sys-fchmod (lambda (port-or-fd mode)))
    (sys-chown (lambda (path owner-id group-id)))
    (sys-utime (lambda (path :optional atime mtime)))
    (sys-chdir (lambda (dir)))
    (sys-pipe (lambda (:key (\(buffering\ :line\)))))
    (sys-mkfifo (lambda (path mode)))
    (sys-isatty (lambda (port-or-fd)))
    (sys-ttyname (lambda (port-or-fd)))
    (sys-truncate (lambda (path length)))
    (sys-ftruncate (lambda (port-or-fd length)))
    (sys-getgrgid (lambda (gid)))
    (sys-getgrnam (lambda (name)))
    (sys-gid->group-name (lambda (gid)))
    (sys-group-name->gid (lambda (name)))
    (sys-getpwuid (lambda (uid)))
    (sys-getpwnam (lambda (name)))
    (sys-uid->user-name (lambda (uid)))
    (sys-user-name->uid (lambda (name)))
    (sys-crypt (lambda (key salt)))
    (sys-setlocale (lambda (category locale)))
    (sys-localeconv (lambda nil))
    (sys-sigset (lambda (signal \.\.\.)))
    (sys-sigset-add! (lambda (sigset signal \.\.\.)))
    (sys-sigset-delete! (lambda (sigset signal \.\.\.)))
    (sys-sigset-fill! (lambda (sigset)))
    (sys-sigset-empty! (lambda (sigset)))
    (sys-signal-name (lambda (signal)))
    (sys-kill (lambda (pid sig)))
    (set-signal-handler! (lambda (signals handler :optional sigmask)))
    (get-signal-handler (lambda (signum)))
    (get-signal-handler-mask (lambda (signum)))
    (get-signal-handlers (lambda nil))
    (get-signal-pending-limit (lambda nil))
    (set-signal-pending-limit (lambda (limit)))
    (with-signal-handlers (syntax (\(handler-clause\ \.\.\.\) thunk)))
    (sys-sigmask (lambda (how mask)))
    (sys-sigsuspend (lambda (mask)))
    (sys-sigwait (lambda (mask)))
    (sys-uname (lambda nil))
    (sys-gethostname (lambda nil))
    (sys-getdomainname (lambda nil))
    (sys-getcwd (lambda nil))
    (sys-getgid (lambda nil))
    (sys-getegid (lambda nil))
    (sys-setgid (lambda (gid)))
    (sys-getuid (lambda nil))
    (sys-geteuid (lambda nil))
    (sys-setuid (lambda (uid)))
    (sys-getgroups (lambda nil))
    (sys-getlogin (lambda nil))
    (sys-getpgrp (lambda nil))
    (sys-getpgid (lambda (pid)))
    (sys-setpgid (lambda (pid pgid)))
    (sys-setsid (lambda nil))
    (sys-getpid (lambda nil))
    (sys-getppid (lambda nil))
    (sys-times (lambda nil))
    (sys-ctermid (lambda nil))
    (sys-getrlimit (lambda (resource)))
    (sys-setrlimit (lambda (resource current :optional maximum)))
    (sys-strerror (lambda (errno)))
    (sys-time (lambda nil))
    (sys-gettimeofday (lambda nil))
    (sys-gmtime (lambda (time)))
    (sys-localtime (lambda (time)))
    (sys-ctime (lambda (time)))
    (sys-difftime (lambda (time1 time0)))
    (sys-asctime (lambda (tm)))
    (sys-strftime (lambda (format tm)))
    (sys-mktime (lambda (tm)))
    (sys-tm->alist (lambda (tm)))
    (current-time (lambda nil))
    (time\? (lambda (obj)))
    (time->seconds (lambda (time)))
    (seconds->time (lambda (seconds)))
    (sys-system (lambda (command)))
    (sys-fork (lambda nil))
    (sys-exec (lambda (command args :key (directory) (iomap) (sigmask))))
    (sys-fork-and-exec (lambda (command args :key (directory) (iomap) (sigmask))))
    (sys-wait (lambda nil))
    (sys-waitpid (lambda (pid :key (nohang) (untraced))))
    (sys-wait-exited\? (lambda (status)))
    (sys-wait-exit-status (lambda (status)))
    (sys-wait-signaled\? (lambda (status)))
    (sys-wait-termsig (lambda (status)))
    (sys-wait-stopped\? (lambda (status)))
    (sys-wait-stopsig (lambda (status)))
    (sys-win-process\? (lambda (obj)))
    (sys-win-process-pid (lambda (handle)))
    (sys-fdset (lambda (elt \.\.\.)))
    (sys-fdset-ref (lambda (fdset port-or-fd)))
    (sys-fdset-set! (lambda (fdset port-or-fd flag)))
    (sys-fdset-copy! (lambda (dest-fdset src-fdset)))
    (sys-fdset-clear! (lambda (fdset)))
    (sys-fdset->list (lambda (fdset)))
    (list->sys-fdset (lambda (fds)))
    (sys-fdset-max-fd (lambda (fdset)))
    (sys-select (lambda (readfds writefds exceptfds :optional timeout)))
    (sys-select! (lambda (readfds writefds exceptfds :optional timeout)))
    (sys-pause (lambda nil))
    (sys-alarm (lambda (seconds)))
    (sys-sleep (lambda (seconds)))
    (sys-nanosleep (lambda (nanoseconds)))
    (sys-random (lambda nil))
    (sys-srandom (lambda (seed)))
    (sys-get-osfhandle (lambda (port-or-fd)))
    (debug-print (syntax (expr)))
    (debug-source-info (lambda (obj)))
    (disasm (lambda (closure)))
    (profiler-start (lambda nil))
    (profiler-stop (lambda nil))
    (profiler-reset (lambda nil))
    (profiler-show (lambda (:key (sort-by) (max-rows))))
    (class-of (lambda (obj)))
    (is-a\? (lambda (obj class)))
    (current-class-of (lambda (obj)))
    (define-class (syntax (name supers \(slot-spec\ \.\.\.\) option \.\.\.)))
    (class-name (lambda (class)))
    (class-precedence-list (lambda (class)))
    (class-direct-supers (lambda (class)))
    (class-direct-subclasses (lambda (class)))
    (class-slots (lambda (class)))
    (class-slot-definition (lambda (class slot-name)))
    (class-direct-slots (lambda (class)))
    (class-direct-methods (lambda (class)))
    (class-slot-accessor (lambda (class slot-name)))
    (slot-definition-name (lambda (slot-def)))
    (slot-definition-options (lambda (slot-def)))
    (slot-definition-allocation (lambda (slot-def)))
    (slot-definition-getter (lambda (slot-def)))
    (slot-definition-setter (lambda (slot-def)))
    (slot-definition-accessor (lambda (slot-def)))
    (slot-definition-option (lambda (slot-def option :optional default)))
    (slot-ref (lambda (obj slot)))
    (slot-set! (lambda (obj slot value)))
    (slot-bound\? (lambda (obj slot)))
    (slot-exists\? (lambda (obj slot)))
    (slot-push! (lambda (obj slot value)))
    (slot-pop! (lambda (obj slot :optional fallback)))
    (class-slot-ref (lambda (class slot-name)))
    (class-slot-set! (lambda (class slot-name obj)))
    (class-slot-bound\? (lambda (class slot-name obj)))
    (change-object-class (lambda (obj orig-class new-class)))
    (define-generic (syntax (name :key (class))))
    (define-method (syntax (name specs body)))
    (slot-ref-using-accessor (lambda (obj slot-accessor)))
    (slot-set-using-accessor! (lambda (obj slot-accessor value)))
    (slot-bound-using-accessor\? (lambda (obj slot-accessor)))
    (slot-initialize-using-accessor! (lambda (obj slot-accessor initargs)))
    (array\? (lambda (obj)))
    (make-array (lambda (shape :optional init)))
    (make-u8array (lambda (shape :optional init)))
    (make-s8array (lambda (shape :optional init)))
    (make-f32array (lambda (shape :optional init)))
    (make-f64array (lambda (shape :optional init)))
    (shape (lambda (bound \.\.\.)))
    (array (lambda (shape init \.\.\.)))
    (array-rank (lambda (array)))
    (array-shape (lambda (array)))
    (array-start (lambda (array dim)))
    (array-end (lambda (array dim)))
    (array-length (lambda (array dim)))
    (array-size (lambda (array)))
    (array-ref (lambda (array k \.\.\.)))
    (array-ref (lambda (array index)))
    (array-set! (lambda (array k \.\.\. value)))
    (array-set! (lambda (array index value)))
    (share-array (lambda (array shape proc)))
    (array-for-each-index (lambda (array proc :optional index)))
    (shape-for-each (lambda (shape proc :optional index)))
    (tabulate-array (lambda (shape proc :optional index)))
    (array-retabulate! (lambda (array shape proc :optional index)))
    (array-retabulate! (lambda (array proc :optional index)))
    (array-map! (lambda (array shape proc array0 array1 \.\.\.)))
    (array-map! (lambda (array proc array0 array1 \.\.\.)))
    (array-map (lambda (shape proc array0 array1 \.\.\.)))
    (array-map (lambda (proc array0 array1 \.\.\.)))
    (array->vector (lambda (array)))
    (array->list (lambda (array)))
    (array-concatenate (lambda (a b :optional dimension)))
    (array-transpose (lambda (array :optional dim1 dim2)))
    (array-rotate-90 (lambda (array :optional dim1 dim2)))
    (array-flip (lambda (array :optional dimension)))
    (array-flip! (lambda (array :optional dimension)))
    (identity-array (lambda (dimension :optional class)))
    (array-inverse (lambda (array)))
    (determinant (lambda (array)))
    (determinant! (lambda (array)))
    (array-mul (lambda (a b)))
    (array-expt (lambda (array pow)))
    (array-div-left (lambda (a b)))
    (array-div-right (lambda (a b)))
    (array-add-elements (lambda (array array-or-scalar \.\.\.)))
    (array-add-elements! (lambda (array array-or-scalar \.\.\.)))
    (array-sub-elements (lambda (array array-or-scalar \.\.\.)))
    (array-sub-elements! (lambda (array array-or-scalar \.\.\.)))
    (array-mul-elements (lambda (array array-or-scalar \.\.\.)))
    (array-mul-elements! (lambda (array array-or-scalar \.\.\.)))
    (array-div-elements (lambda (array array-or-scalar \.\.\.)))
    (array-div-elements! (lambda (array array-or-scalar \.\.\.)))
    (ces-conversion-supported\? (lambda (from-ces to-ces)))
    (ces-equivalent\? (lambda (ces-a ces-b :optional unknown-value)))
    (ces-upper-compatible\? (lambda (ces-a ces-b :optional unknown-value)))
    (ces-guess-from-string (lambda (string scheme)))
    (open-input-conversion-port (lambda (source from-code :key (to-code) (buffer-size) (owner\?))))
    (open-output-conversion-port (lambda (sink to-code :key (from-code) (buffer-size) (owner\?))))
    (ces-convert (lambda (string from-code :optional to-code)))
    (call-with-input-conversion (lambda (iport proc :key (encoding) (conversion-buffer-size))))
    (call-with-output-conversion (lambda (oport proc :key (encoding) (conversion-buffer-size))))
    (with-input-conversion (lambda (iport thunk :key (encoding) (conversion-buffer-size))))
    (with-output-conversion (lambda (oport thunk :key (encoding) (conversion-buffer-size))))
    (wrap-with-input-conversion (lambda (port from-code :key (to-code) (owner\?) (buffer-size))))
    (wrap-with-output-conversion (lambda (port to-code :key (from-code) (owner\?) (buffer-size))))
    (call-with-iterators (lambda (collections proc)))
    (gauche-config (lambda (option)))
    (make-bimap (lambda (left-map right-map)))
    (bimap-left (lambda (bimap)))
    (bimap-right (lambda (bimap)))
    (bimap-left-get (lambda (bimap key :optional default)))
    (bimap-right-get (lambda (bimap key :optional default)))
    (bimap-left-exists\? (lambda (bimap key)))
    (bimap-right-exists\? (lambda (bimap key)))
    (bimap-put! (lambda (bimap x y &key \(on-conflict\ :supersede\))))
    (bimap-left-delete! (lambda (bimap key)))
    (bimap-right-delete! (lambda (bimap key)))
    (sys-fcntl (lambda (port-or-fd operation :optional arg)))
    (make-hook (lambda (:optional \(arity\ 0\))))
    (hook\? (lambda (obj)))
    (hook-empty\? (lambda (hook)))
    (apropos (syntax (pattern :optional module)))
    (info (lambda (symbol)))
    (complete-sexp\? (lambda (str)))
    (log-open (lambda (path :key (prefix) (program-name))))
    (make-sockaddrs (lambda (host port :optional proto)))
    (inet-string->address (lambda (address)))
    (inet-string->address! (lambda (address buf)))
    (inet-address->string (lambda (address protocol)))
    (make-client-socket (lambda (:optional address-spec \.\.\.)))
    (make-server-socket (lambda (:optional address-spec \.\.\.)))
    (make-server-sockets (lambda (host port :key (reuse-addr\?) (sock-init))))
    (socket-address (lambda (socket)))
    (socket-input-port (lambda (socket :key (\(buffering\ :modest\)))))
    (socket-output-port (lambda (socket :key (\(buffering\ :line\)))))
    (socket-close (lambda (socket)))
    (call-with-client-socket (lambda (socket proc :key (input-buffering) (output-buffering))))
    (make-socket (lambda (domain type :optional protocol)))
    (socket-fd (lambda (socket)))
    (socket-status (lambda (socket)))
    (socket-bind (lambda (socket address)))
    (socket-listen (lambda (socket backlog)))
    (socket-accept (lambda (socket)))
    (socket-connect (lambda (socket address)))
    (socket-shutdown (lambda (socket how)))
    (socket-getsockname (lambda (socket)))
    (socket-getpeername (lambda (socket)))
    (socket-send (lambda (socket msg :optional flags)))
    (socket-sendto (lambda (socket msg to-address :optional flags\\\.)))
    (socket-sendmsg (lambda (socket msghdr :optional flags)))
    (socket-buildmsg (lambda (addr iov control flags :optional buf)))
    (socket-recv! (lambda (socket buf :optional flags)))
    (socket-recvfrom! (lambda (socket buf addrs :optional flags)))
    (socket-recv (lambda (socket bytes :optional flags)))
    (socket-recvfrom (lambda (socket bytes :optional flags)))
    (socket-setsockopt (lambda (socket level option value)))
    (socket-getsockopt (lambda (socket level option rsize)))
    (inet-checksum (lambda (packet size)))
    (sys-gethostbyname (lambda (name)))
    (sys-gethostbyaddr (lambda (addr proto)))
    (sys-getservbyname (lambda (name proto)))
    (sys-getservbyport (lambda (port proto)))
    (sys-getprotobyname (lambda (name)))
    (sys-getprotobynumber (lambda (number)))
    (sys-getaddrinfo (lambda (nodename servname hints)))
    (sys-ntohs (lambda (integer)))
    (sys-ntohl (lambda (integer)))
    (sys-htons (lambda (integer)))
    (sys-htonl (lambda (integer)))
    (make-parameter (lambda (value :optional filter)))
    (parameterize (syntax (\(\(param\ value\)\ \.\.\.\) body \.\.\.)))
    (let-args (syntax (args)))
    (parse-options (syntax (args \(option-clause\ \.\.\.\))))
    (make-option-parser (syntax (\(option-clause\ \.\.\.\))))
    (reset (syntax (expr \.\.\.)))
    (shift (syntax (var expr \.\.\.)))
    (call/pc (lambda (proc)))
    (run-process (lambda (cmd/args :key (redirects) (input) (output) (error) (@))))
    (process\? (lambda (obj)))
    (process-alive\? (lambda (process)))
    (process-list (lambda nil))
    (process-wait (lambda (process :optional nohang error-on-nonzero-status)))
    (process-wait-any (lambda (:optional nohang)))
    (process-exit-status (lambda (process)))
    (process-send-signal (lambda (process signal)))
    (process-kill (lambda (process)))
    (process-stop (lambda (process)))
    (process-continue (lambda (process)))
    (open-input-process-port (lambda (command :key (input) (error) (encoding) (conversion-buffer-size))))
    (call-with-input-process (lambda (command proc :key (input) (error) (encoding) (conversion-buffer-size) (on-abnormal-exit))))
    (with-input-from-process (lambda (command thunk :key (input) (error) (encoding) (conversion-buffer-size) (on-abnormal-exit))))
    (open-output-process-port (lambda (command :key (output) (error) (encoding) (conversion-buffer-size))))
    (call-with-output-process (lambda (command proc :key (output) (error) (encoding) (conversion-buffer-size) (on-abnormal-exit))))
    (with-output-to-process (lambda (command thunk :key (output) (error) (encoding) (conversion-buffer-size) (on-abnormal-exit))))
    (call-with-process-io (lambda (command proc :key (error) (encoding) (conversion-buffer-size) (on-abnormal-exit))))
    (process-output->string (lambda (command :key (error) (encoding) (conversion-buffer-size) (on-abnormal-exit))))
    (process-output->string-list (lambda (command :key (error) (encoding) (conversion-buffer-size) (on-abnormal-exit))))
    (shell-escape-string (lambda (arg)))
    (define-record-type (syntax (type-spec ctor-spec pred-spec field-spec \.\.\.)))
    (record\? (lambda (obj)))
    (record-rtd (lambda (record)))
    (rtd-name (lambda (rtd)))
    (rtd-parent (lambda (rtd)))
    (rtd-field-names (lambda (rtd)))
    (rtd-all-field-names (lambda (rtd)))
    (rtd-field-mutable\? (lambda (rtd field-name)))
    (make-rtd (lambda (name field-specs :optional parent)))
    (rtd\? (lambda (obj)))
    (rtd-constructor (lambda (rtd :optional field-specs)))
    (rtd-predicate (lambda (rtd)))
    (rtd-accessor (lambda (rtd field-name)))
    (rtd-mutator (lambda (rtd field-name)))
    (pseudo-rtd (lambda (instance-class)))
    (reload (lambda (module-name :optional rule \.\.\.)))
    (reload-modified-modules (lambda (:optional module-rules)))
    (module-reload-rules (lambda (:optional module-rules)))
    (reload-verbose (lambda (:optional flag)))
    (sys-openlog (lambda (ident option facility)))
    (sys-closelog (lambda nil))
    (sys-setlogmask (lambda (mask)))
    (sys-logmask (lambda (level)))
    (sys-tcgetattr (lambda (port-or-fd)))
    (sys-tcsetattr (lambda (port-or-fd when termios)))
    (sys-tcsendbreak (lambda (port-or-fd duration)))
    (sys-tcdrain (lambda (port-or-fd)))
    (sys-tcflush (lambda (port-or-fd queue)))
    (sys-tcflow (lambda (port-or-fd action)))
    (sys-tcgetpgrp (lambda (port-or-fd)))
    (sys-tcsetpgrp (lambda (port-or-fd pgrp)))
    (sys-cfgetispeed (lambda (termios)))
    (sys-cfsetispeed (lambda (termios speed)))
    (sys-cfgetospeed (lambda (termios)))
    (sys-cfsetospeed (lambda (termios speed)))
    (sys-openpty (lambda (:optional term)))
    (sys-forkpty (lambda (:optional term)))
    (sys-forkpty-and-exec (lambda (command args :key (iomap) (term) (sigmask))))
    (without-echoing (lambda (iport proc)))
    (test-start (lambda (module-name)))
    (test-section (lambda (section-name)))
    (test-end (lambda nil))
    (test-record-file (lambda (file)))
    (test* (syntax (name expected expr :optional compare)))
    (test (lambda (name expected thunk :optional check)))
    (test-error (lambda (:optional \(condition-type\ <error>\))))
    (test-module (lambda (module :key (allow-undefined))))
    (gauche-thread-type (lambda nil))
    (current-thread (lambda nil))
    (thread\? (lambda (obj)))
    (make-thread (lambda (thunk :optional name)))
    (thread-state (lambda (thread)))
    (thread-name (lambda (thread)))
    (thread-specific (lambda (thread)))
    (thread-specific-set! (lambda (thread value)))
    (thread-start! (lambda (thread)))
    (thread-yield! (lambda nil))
    (thread-sleep! (lambda (timeout)))
    (thread-stop! (lambda (thread :optional timeout timeout-val)))
    (thread-cont! (lambda (thread)))
    (thread-terminate! (lambda (thread)))
    (thread-join! (lambda (thread :optional timeout timeout-val)))
    (mutex\? (lambda (obj)))
    (make-mutex (lambda (:optional name)))
    (mutex-name (lambda (mutex)))
    (mutex-specific (lambda (mutex)))
    (mutex-specific-set! (lambda (mutex value)))
    (mutex-state (lambda (mutex)))
    (mutex-lock! (lambda (mutex :optional timeout thread)))
    (mutex-unlock! (lambda (mutex :optional condition-variable timeout)))
    (with-locking-mutex (lambda (mutex thunk)))
    (condition-variable\? (lambda (obj)))
    (make-condition-variable (lambda (:optional name)))
    (condition-variable-name (lambda (cv)))
    (condition-variable-specific (lambda (cv)))
    (condition-variable-specific-set! (lambda (cv value)))
    (condition-variable-signal! (lambda (cv)))
    (condition-variable-broadcast! (lambda (cv)))
    (join-timeout-exception\? (lambda (obj)))
    (abandoned-mutex-exception\? (lambda (obj)))
    (terminated-thread-exception\? (lambda (obj)))
    (uncaught-exception\? (lambda (obj)))
    (uncaught-exception-reason (lambda (exc)))
    (time (syntax (expr expr2 \.\.\.)))
    (with-time-counter (syntax (counter expr \.\.\.)))
    (uvector-size (lambda (uvector :optional start end)))
    (string->s8vector (lambda (string :optional start end)))
    (string->u8vector (lambda (string :optional start end)))
    (string->s8vector! (lambda (target tstart string :optional start end)))
    (string->u8vector! (lambda (target tstart string :optional start end)))
    (s8vector->string (lambda (vec :optional start end)))
    (u8vector->string (lambda (vec :optional start end)))
    (string->s32vector (lambda (string :optional start end)))
    (string->u32vector (lambda (string :optional start end)))
    (s32vector->string (lambda (vec :optional start end)))
    (u32vector->string (lambda (vec :optional start end)))
    (uvector-alias (lambda (uvector-class vec :optional start end)))
    (read-block! (lambda (vec :optional iport start end endian)))
    (write-block (lambda (vec :optional oport start end endian)))
    (version=\? (lambda (ver1 ver2)))
    (version<\? (lambda (ver1 ver2)))
    (version<=\? (lambda (ver1 ver2)))
    (version>\? (lambda (ver1 ver2)))
    (version>=\? (lambda (ver1 ver2)))
    (version-compare (lambda (ver1 ver2)))
    (relnum-compare (lambda (rel1 rel2)))
    (open-input-uvector (lambda (uvector)))
    (open-output-uvector (lambda (uvector)))
    (cond-expand (syntax (\(feature-requirement\ command-or-definition\ \.\.\.\) \.\.\.)))
    (xcons (lambda (cd ca)))
    (cons* (lambda (elt1 elt2 \.\.\.)))
    (list-tabulate (lambda (n init-proc)))
    (circular-list (lambda (elt1 elt2 \.\.\.)))
    (iota (lambda (count :optional \(start\ 0\) \(step\ 1\))))
    (proper-list\? (lambda (x)))
    (circular-list\? (lambda (x)))
    (dotted-list\? (lambda (x)))
    (null-list\? (lambda (list)))
    (not-pair\? (lambda (x)))
    (list= (lambda (elt= list \.\.\.)))
    (first (lambda (pair)))
    (second (lambda (pair)))
    (third (lambda (pair)))
    (fourth (lambda (pair)))
    (fifth (lambda (pair)))
    (sixth (lambda (pair)))
    (seventh (lambda (pair)))
    (eighth (lambda (pair)))
    (ninth (lambda (pair)))
    (tenth (lambda (pair)))
    (car+cdr (lambda (pair)))
    (take (lambda (x i)))
    (drop (lambda (x i)))
    (take-right (lambda (flist i)))
    (drop-right (lambda (flist i)))
    (take! (lambda (x i)))
    (drop-right! (lambda (x i)))
    (split-at (lambda (x i)))
    (split-at! (lambda (x i)))
    (last (lambda (pair)))
    (length+ (lambda (x)))
    (concatenate (lambda (list-of-lists)))
    (concatenate! (lambda (list-of-lists!)))
    (append-reverse (lambda (rev-head tail)))
    (append-reverse! (lambda (rev-head tail)))
    (zip (lambda (clist1 clist2 \.\.\.)))
    (unzip1 (lambda (list)))
    (unzip2 (lambda (list)))
    (unzip3 (lambda (list)))
    (unzip4 (lambda (list)))
    (unzip5 (lambda (list)))
    (count (lambda (pred clist1 clist2 \.\.\.)))
    (fold (lambda (kons knil clist1 clist2 \.\.\.)))
    (fold-right (lambda (kons knil clist1 clist2 \.\.\.)))
    (pair-fold (lambda (kons knil clist1 clist2 \.\.\.)))
    (pair-fold-right (lambda (kons knil clist1 clist2 \.\.\.)))
    (reduce (lambda (f ridentity list)))
    (reduce-right (lambda (f ridentity list)))
    (unfold (lambda (p f g seed :optional tail-gen)))
    (unfold-right (lambda (p f g seed :optional tail)))
    (append-map (lambda (f clist1 clist2 \.\.\.)))
    (append-map! (lambda (f clist1 clist2 \.\.\.)))
    (map! (lambda (f clist1 clist2 \.\.\.)))
    (map-in-order (lambda (f clist1 clist2 \.\.\.)))
    (pair-for-each (lambda (f clist1 clist2 \.\.\.)))
    (filter-map (lambda (f clist1 clist2 \.\.\.)))
    (filter (lambda (pred list)))
    (filter! (lambda (pred list)))
    (remove (lambda (pred list)))
    (remove! (lambda (pred list)))
    (partition (lambda (pred list)))
    (partition! (lambda (pred list)))
    (find (lambda (pred clist)))
    (find-tail (lambda (pred clist)))
    (take-while (lambda (pred clist)))
    (take-while! (lambda (pred list)))
    (drop-while (lambda (pred clist)))
    (span (lambda (pred clist)))
    (span! (lambda (pred list)))
    (break (lambda (pred clist)))
    (break! (lambda (pred list)))
    (any (lambda (pred clist1 clist2 \.\.\.)))
    (every (lambda (pred clist1 clist2 \.\.\.)))
    (list-index (lambda (pred clist1 clist2 \.\.\.)))
    (delete (lambda (x list :optional elt=)))
    (delete! (lambda (x list :optional elt=)))
    (delete-duplicates (lambda (list :optional elt=)))
    (delete-duplicates! (lambda (list :optional elt=)))
    (alist-cons (lambda (key datum alist)))
    (alist-copy (lambda (alist)))
    (alist-delete (lambda (key alist :optional =)))
    (alist-delete! (lambda (key alist :optional =)))
    (lset<= (lambda (elt= list1 \.\.\.)))
    (lset= (lambda (elt= list1 list2 \.\.\.)))
    (lset-adjoin (lambda (elt= list elt \.\.\.)))
    (lset-union (lambda (elt= list1 \.\.\.)))
    (lset-intersection (lambda (elt= list1 list2 \.\.\.)))
    (lset-difference (lambda (elt= list1 list2 \.\.\.)))
    (lset-xor (lambda (elt= list1 \.\.\.)))
    (lset-diff+intersection (lambda (elt= list1 list2 \.\.\.)))
    (lset-union! (lambda (elt= list \.\.\.)))
    (lset-intersection! (lambda (elt= list1 list2 \.\.\.)))
    (lset-difference! (lambda (elt= list1 list2 \.\.\.)))
    (lset-xor! (lambda (elt= list1 \.\.\.)))
    (lset-diff+intersection! (lambda (elt= list1 list2 \.\.\.)))
    (let (syntax nil))
    (let (syntax (name)))
    (let (syntax nil))
    (let-values (syntax (\(\(vars\ expr\)\ \.\.\.\) body \.\.\.)))
    (let*-values (syntax (\(\(vars\ expr\)\ \.\.\.\) body \.\.\.)))
    (string-null\? (lambda (s)))
    (string-every (lambda (char/char-set/pred s :optional start end)))
    (string-any (lambda (char/char-set/pred s :optional start end)))
    (string-tabulate (lambda (proc len)))
    (reverse-list->string (lambda (char-list)))
    (substring/shared (lambda (s start :optional end)))
    (string-copy! (lambda (target tstart s :optional start end)))
    (string-take (lambda (s nchars)))
    (string-drop (lambda (s nchars)))
    (string-take-right (lambda (s nchars)))
    (string-drop-right (lambda (s nchars)))
    (string-pad (lambda (s len :optional char start end)))
    (string-pad-right (lambda (s len :optional char start end)))
    (string-trim (lambda (s :optional char/char-set/pred start end)))
    (string-trim-right (lambda (s :optional char/char-set/pred start end)))
    (string-trim-both (lambda (s :optional char/char-set/pred start end)))
    (string-compare (lambda (s1 s2 proc< proc= proc> :optional start1 end1 start2 end2)))
    (string-compare-ci (lambda (s1 s2 proc< proc= proc> :optional start1 end1 start2 end2)))
    (string= (lambda (s1 s2 :optional start1 end1 start2 end2)))
    (string<> (lambda (s1 s2 :optional start1 end1 start2 end2)))
    (string< (lambda (s1 s2 :optional start1 end1 start2 end2)))
    (string<= (lambda (s1 s2 :optional start1 end1 start2 end2)))
    (string> (lambda (s1 s2 :optional start1 end1 start2 end2)))
    (string>= (lambda (s1 s2 :optional start1 end1 start2 end2)))
    (string-ci= (lambda (s1 s2 :optional start1 end1 start2 end2)))
    (string-ci<> (lambda (s1 s2 :optional start1 end1 start2 end2)))
    (string-ci< (lambda (s1 s2 :optional start1 end1 start2 end2)))
    (string-ci<= (lambda (s1 s2 :optional start1 end1 start2 end2)))
    (string-ci> (lambda (s1 s2 :optional start1 end1 start2 end2)))
    (string-ci>= (lambda (s1 s2 :optional start1 end1 start2 end2)))
    (string-hash (lambda (s :optional bound start end)))
    (string-hash-ci (lambda (s :optional bound start end)))
    (string-prefix-length (lambda (s1 s2 :optional start1 end1 start2 end2)))
    (string-suffix-length (lambda (s1 s2 :optional start1 end1 start2 end2)))
    (string-prefix-length-ci (lambda (s1 s2 :optional start1 end1 start2 end2)))
    (string-suffix-length-ci (lambda (s1 s2 :optional start1 end1 start2 end2)))
    (string-prefix\? (lambda (s1 s2 :optional start1 end1 start2 end2)))
    (string-suffix\? (lambda (s1 s2 :optional start1 end1 start2 end2)))
    (string-prefix-ci\? (lambda (s1 s2 :optional start1 end1 start2 end2)))
    (string-suffix-ci\? (lambda (s1 s2 :optional start1 end1 start2 end2)))
    (string-index (lambda (s char/char-set/pred :optional start end)))
    (string-index-right (lambda (s char/char-set/pred :optional start end)))
    (string-skip (lambda (s char/char-set/pred :optional start end)))
    (string-skip-right (lambda (s char/char-set/pred :optional start end)))
    (string-count (lambda (s char/char-set/pred :optional start end)))
    (string-contains (lambda (s1 s2 :optional start1 end1 start2 end2)))
    (string-contains-ci (lambda (s1 s2 :optional start1 end1 start2 end2)))
    (string-titlecase (lambda (s :optional start end)))
    (string-titlecase! (lambda (s :optional start end)))
    (string-upcase (lambda (s :optional start end)))
    (string-upcase! (lambda (s :optional start end)))
    (string-downcase (lambda (s :optional start end)))
    (string-downcase! (lambda (s :optional start end)))
    (string-reverse (lambda (s :optional start end)))
    (string-reverse! (lambda (s :optional start end)))
    (string-concatenate (lambda (string-list)))
    (string-concatenate/shared (lambda (string-list)))
    (string-append/shared (lambda (s \.\.\.)))
    (string-concatenate-reverse (lambda (string-list)))
    (string-concatenate-reverse/shared (lambda (string-list)))
    (string-map (lambda (proc s :optional start end)))
    (string-map! (lambda (proc s :optional start end)))
    (string-fold (lambda (kons knil s :optional start end)))
    (string-fold-right (lambda (kons knil s :optional start end)))
    (string-unfold (lambda (p f g seed :optional base make-final)))
    (string-unfold-right (lambda (p f g seed :optional base make-final)))
    (string-for-each (lambda (proc s :optional start end)))
    (string-for-each-index (lambda (proc s :optional start end)))
    (xsubstring (lambda (s from :optional to start end)))
    (string-xcopy! (lambda (target tstart s sfrom :optional sto start end)))
    (string-replace (lambda (s1 s2 start1 end1 :optional start2 end2)))
    (string-tokenize (lambda (s :optional token-set start end)))
    (string-filter (lambda (s char/char-set/pred :optional start end)))
    (string-delete (lambda (s char/char-set/pred :optional start end)))
    (string-parse-start+end (lambda (proc s args)))
    (string-parse-final-start+end (lambda (proc s args)))
    (let-string-start+end (syntax (\(start\ end\ \[rest\]\) proc-exp s-exp args-exp body \.\.\.)))
    (check-substring-spec (lambda (proc s start end)))
    (substring-spec-ok\? (lambda (s start end)))
    (make-kmp-restart-vector (lambda (s :optional c= start end)))
    (kmp-step (lambda (pat rv c i c= p-start)))
    (string-kmp-partial-search (lambda (pat rv s i :optional c= p-start s-start s-end)))
    (list->char-set (lambda (char-list :optional base-cs)))
    (list->char-set! (lambda (char-list base-cs)))
    (string->char-set (lambda (s :optional base-cs)))
    (string->char-set! (lambda (s base-cs)))
    (char-set-filter (lambda (pred char-set :optional base-cs)))
    (char-set-filter! (lambda (pred char-set base-cs)))
    (ucs-range->char-set (lambda (lower upper :optional error\? base-cs)))
    (ucs-range->char-set! (lambda (lower upper error\? base-cs)))
    (integer-range->char-set (lambda (lower upper :optional error\? base-cs)))
    (integer-range->char-set! (lambda (lower upper error\? base-cs)))
    (->char-set (lambda (x)))
    (char-set= (lambda (char-set1 \.\.\.)))
    (char-set<= (lambda (char-set1 \.\.\.)))
    (char-set-hash (lambda (char-set :optional bound)))
    (char-set-cursor (lambda (char-set)))
    (char-set-ref (lambda (char-set cursor)))
    (char-set-cursor-next (lambda (char-set cursor)))
    (end-of-char-set\? (lambda (ccursor)))
    (char-set-fold (lambda (kons knil char-set)))
    (char-set-unfold (lambda (pred fun gen seed :optional base-char-set)))
    (char-set-unfold! (lambda (pred fun gen seed base-char-set)))
    (char-set-for-each (lambda (proc char-set)))
    (char-set-map (lambda (proc char-set)))
    (char-set-size (lambda (char-set)))
    (char-set-count (lambda (pred char-set)))
    (char-set->list (lambda (char-set)))
    (char-set->string (lambda (char-set)))
    (char-set-every (lambda (pred char-set)))
    (char-set-any (lambda (pred char-set)))
    (char-set-adjoin (lambda (char-set char1 \.\.\.)))
    (char-set-adjoin! (lambda (char-set char1 \.\.\.)))
    (char-set-delete (lambda (char-set char1 \.\.\.)))
    (char-set-delete! (lambda (char-set char1 \.\.\.)))
    (char-set-complement (lambda (char-set)))
    (char-set-complement! (lambda (char-set)))
    (char-set-union (lambda (char-set \.\.\.)))
    (char-set-union! (lambda (char-set1 char-set2 \.\.\.)))
    (char-set-intersection (lambda (char-set \.\.\.)))
    (char-set-intersection! (lambda (char-set1 char-set2 \.\.\.)))
    (char-set-difference (lambda (char-set1 char-set2 \.\.\.)))
    (char-set-difference! (lambda (char-set1 char-set2 \.\.\.)))
    (char-set-xor (lambda (char-set \.\.\.)))
    (char-set-xor! (lambda (char-set1 char-set2 \.\.\.)))
    (char-set-diff+intersection (lambda (char-set1 char-set2 \.\.\.)))
    (char-set-diff+intersection! (lambda (char-set1 char-set2 char-set3 \.\.\.)))
    (current-time (lambda (:optional time-type)))
    (current-date (lambda (:optional tz-offset)))
    (current-julian-day (lambda nil))
    (current-modified-julian-day (lambda nil))
    (time-resolution (lambda nil))
    (make-time (lambda (type nanoseconds seconds)))
    (time-type (lambda (time)))
    (time-second (lambda (time)))
    (time-nanosecond (lambda (time)))
    (set-time-type! (lambda (time type)))
    (set-time-second! (lambda (time second)))
    (set-time-nanosecond! (lambda (time nanosecond)))
    (copy-time (lambda (time)))
    (time=\? (lambda (time0 time1)))
    (time<\? (lambda (time0 time1)))
    (time<=\? (lambda (time0 time1)))
    (time>\? (lambda (time0 time1)))
    (time>=\? (lambda (time0 time1)))
    (time-difference (lambda (time0 time1)))
    (time-difference! (lambda (time0 time1)))
    (add-duration (lambda (time0 time-duration)))
    (add-duration! (lambda (time0 time-duration)))
    (subtract-duration (lambda (time0 time-duration)))
    (subtract-duration! (lambda (time0 time-duration)))
    (make-date (lambda (nanosecond second minute hour day month year zone-offset)))
    (date\? (lambda (obj)))
    (date-nanosecond (lambda (date)))
    (date-second (lambda (date)))
    (date-minute (lambda (date)))
    (date-hour (lambda (date)))
    (date-day (lambda (date)))
    (date-month (lambda (date)))
    (date-year (lambda (date)))
    (date-zone-offset (lambda (date)))
    (date-year-day (lambda (date)))
    (date-week-day (lambda (date)))
    (date-week-number (lambda (date day-of-week-starting-week)))
    (date->julian-day (lambda (date)))
    (date->modified-julian-day (lambda (date)))
    (date->time-monotonic (lambda (date)))
    (date->time-tai (lambda (date)))
    (date->time-utc (lambda (date)))
    (julian-day->date (lambda (jd :optional tz-offset)))
    (julian-day->time-monotonic (lambda (jd)))
    (julian-day->time-tai (lambda (jd)))
    (julian-day->time-utc (lambda (jd)))
    (modified-julian-day->date (lambda (jd :optional tz-offset)))
    (modified-julian-day->time-monotonic (lambda (jd)))
    (modified-julian-day->time-tai (lambda (jd)))
    (modified-julian-day->time-utc (lambda (jd)))
    (time-monotonic->date (lambda (time :optional tz-offset)))
    (time-monotonic->julian-day (lambda (time)))
    (time-monotonic->modified-julian-day (lambda (time)))
    (time-monotonic->time-tai (lambda (time)))
    (time-monotonic->time-tai! (lambda (time)))
    (time-monotonic->time-utc (lambda (time)))
    (time-monotonic->time-utc! (lambda (time)))
    (time-tai->date (lambda (time :optional tz-offset)))
    (time-tai->julian-day (lambda (time)))
    (time-tai->modified-julian-day (lambda (time)))
    (time-tai->time-monotonic (lambda (time)))
    (time-tai->time-monotonic! (lambda (time)))
    (time-tai->time-utc (lambda (time)))
    (time-tai->time-utc! (lambda (time)))
    (time-utc->date (lambda (time :optional tz-offset)))
    (time-utc->julian-day (lambda (time)))
    (time-utc->modified-julian-day (lambda (time)))
    (time-utc->time-monotonic (lambda (time)))
    (time-utc->time-monotonic! (lambda (time)))
    (time-utc->time-tai (lambda (time)))
    (time-utc->time-tai! (lambda (time)))
    (date->string (lambda (date :optional format-string)))
    (string->date (lambda (string template-string)))
    (random-integer (lambda (n)))
    (random-real (lambda nil))
    (make-random-source (lambda nil))
    (random-source\? (lambda (obj)))
    (random-source-state-ref (lambda (s)))
    (random-source-state-set! (lambda (s state)))
    (random-source-randomize! (lambda (s)))
    (random-source-pseudo-randomize! (lambda (s i j)))
    (random-source-make-integers (lambda (s)))
    (random-source-make-reals (lambda (s :optional unit)))
    (declare-bundle! (lambda (bundle-specifier association-list)))
    (save-bundle! (lambda (bundle-specifier)))
    (load-bundle! (lambda (bundle-specifier)))
    (localized-template (lambda (package-name message-template-name)))
    (format (lambda (format-string args)))
    (args-fold (lambda (args options unrecognized-proc operand-proc :rest seeds)))
    (option (lambda (names require-arg\? optional-arg\? processor)))
    (option\? (lambda (obj)))
    (option-names (lambda (option)))
    (option-required-arg\? (lambda (option)))
    (option-optional-arg\? (lambda (option)))
    (option-processor (lambda nil))
    (do-ec (syntax (qualifier \.\.\. body)))
    (list-ec (syntax (qualifier \.\.\. body)))
    (append-ec (syntax (qualifier \.\.\. body)))
    (string-ec (syntax (qualifier \.\.\. body)))
    (string-append-ec (syntax (qualifier \.\.\. body)))
    (vector-ec (syntax (qualifier \.\.\. body)))
    (vector-of-length-ec (syntax (k qualifier \.\.\. body)))
    (sum-ec (syntax (qualifier \.\.\. body)))
    (product-ec (syntax (qualifier \.\.\. body)))
    (min-ec (syntax (qualifier \.\.\. body)))
    (max-ec (syntax (qualifier \.\.\. body)))
    (any\?-ec (syntax (qualifier \.\.\. test)))
    (every\?-ec (syntax (qualifier \.\.\. test)))
    (first-ec (syntax (default qualifier \.\.\. body)))
    (last-ec (syntax (default qualifier \.\.\. body)))
    (fold-ec (syntax (seed qualifier \.\.\. expr proc)))
    (fold3-ec (syntax (seed qualifier \.\.\. expr init proc)))
    (vector-unfold (lambda (f length seed \.\.\.)))
    (vector-unfold-right (lambda (f length seed \.\.\.)))
    (vector-reverse-copy (lambda (vec :optional start end)))
    (vector-append (lambda (vec \.\.\.)))
    (vector-concatenate (lambda (list-of-vectors)))
    (vector-empty\? (lambda (vec)))
    (vector= (lambda (elt= vec \.\.\.)))
    (vector-fold (lambda (kons knil vec1 vec2 \.\.\.)))
    (vector-fold-right (lambda (kons knil vec1 vec2 \.\.\.)))
    (vector-map (lambda (f vec1 vec2 \.\.\.)))
    (vector-map! (lambda (f vec1 vec2 \.\.\.)))
    (vector-for-each (lambda (f vec1 vec2 \.\.\.)))
    (vector-count (lambda (pred vec1 vec2 \.\.\.)))
    (vector-index (lambda (pred vec1 vec2 \.\.\.)))
    (vector-index-right (lambda (pred vec1 vec2 \.\.\.)))
    (vector-skip (lambda (pred vec1 vec2 \.\.\.)))
    (vector-skip-right (lambda (pred vec1 vec2 \.\.\.)))
    (vector-binary-search (lambda (vec value cmp :optional start end)))
    (vector-any (lambda (pred vec1 vec2 \.\.\.)))
    (vector-every (lambda (pred vec1 vec2 \.\.\.)))
    (vector-swap! (lambda (vec i j)))
    (vector-reverse! (lambda (vec :optional start end)))
    (vector-copy! (lambda (target tstart source :optional sstart send)))
    (vector-reverse-copy! (lambda (target tstart source :optional sstart send)))
    (reverse-vector->list (lambda (vec :optional start end)))
    (reverse-list->vector (lambda (list :optional start end)))
    (require-extension (syntax (clause \.\.\.)))
    (get-environment-variable (lambda (name)))
    (get-environment-variables (lambda nil))
    (read-u8 (lambda (:optional port endian)))
    (read-u16 (lambda (:optional port endian)))
    (read-u32 (lambda (:optional port endian)))
    (read-u64 (lambda (:optional port endian)))
    (read-s8 (lambda (:optional port endian)))
    (read-s16 (lambda (:optional port endian)))
    (read-s32 (lambda (:optional port endian)))
    (read-s64 (lambda (:optional port endian)))
    (read-uint (lambda (size :optional port endian)))
    (read-sint (lambda (size :optional port endian)))
    (read-ber-integer (lambda (:optional port)))
    (write-u8 (lambda (val :optional port endian)))
    (write-u16 (lambda (val :optional port endian)))
    (write-u32 (lambda (val :optional port endian)))
    (write-u64 (lambda (val :optional port endian)))
    (write-s8 (lambda (val :optional port endian)))
    (write-s16 (lambda (val :optional port endian)))
    (write-s32 (lambda (val :optional port endian)))
    (write-s64 (lambda (val :optional port endian)))
    (write-uint (lambda (size val :optional port endian)))
    (write-sint (lambda (size val :optional port endian)))
    (write-ber-integer (lambda (val :optional port)))
    (read-f16 (lambda (:optional port endian)))
    (read-f32 (lambda (:optional port endian)))
    (read-f64 (lambda (:optional port endian)))
    (write-f16 (lambda (val :optional port endian)))
    (write-f32 (lambda (val :optional port endian)))
    (write-f64 (lambda (val :optional port endian)))
    (get-u8 (lambda (uv pos :optional endian)))
    (get-u16 (lambda (uv pos :optional endian)))
    (get-u32 (lambda (uv pos :optional endian)))
    (get-u64 (lambda (uv pos :optional endian)))
    (get-s8 (lambda (uv pos :optional endian)))
    (get-s16 (lambda (uv pos :optional endian)))
    (get-s32 (lambda (uv pos :optional endian)))
    (get-s64 (lambda (uv pos :optional endian)))
    (get-f16 (lambda (uv pos :optional endian)))
    (get-f32 (lambda (uv pos :optional endian)))
    (get-f64 (lambda (uv pos :optional endian)))
    (get-u16be (lambda (uv pos)))
    (get-u16le (lambda (uv pos)))
    (get-u32be (lambda (uv pos)))
    (get-u32le (lambda (uv pos)))
    (get-u64be (lambda (uv pos)))
    (get-u64le (lambda (uv pos)))
    (get-s16be (lambda (uv pos)))
    (get-s16le (lambda (uv pos)))
    (get-s32be (lambda (uv pos)))
    (get-s32le (lambda (uv pos)))
    (get-s64be (lambda (uv pos)))
    (get-s64le (lambda (uv pos)))
    (get-f16be (lambda (uv pos)))
    (get-f16le (lambda (uv pos)))
    (get-f32be (lambda (uv pos)))
    (get-f32le (lambda (uv pos)))
    (get-f64be (lambda (uv pos)))
    (get-f64le (lambda (uv pos)))
    (put-u8! (lambda (uv pos val :optional endian)))
    (put-u16! (lambda (uv pos val :optional endian)))
    (put-u32! (lambda (uv pos val :optional endian)))
    (put-u64! (lambda (uv pos val :optional endian)))
    (put-s8! (lambda (uv pos val :optional endian)))
    (put-s16! (lambda (uv pos val :optional endian)))
    (put-s32! (lambda (uv pos val :optional endian)))
    (put-s64! (lambda (uv pos val :optional endian)))
    (put-f16! (lambda (uv pos val :optional endian)))
    (put-f32! (lambda (uv pos val :optional endian)))
    (put-f64! (lambda (uv pos val :optional endian)))
    (put-u16be! (lambda (uv pos val)))
    (put-u16le! (lambda (uv pos val)))
    (put-u32be! (lambda (uv pos val)))
    (put-u32le! (lambda (uv pos val)))
    (put-u64be! (lambda (uv pos val)))
    (put-u64le! (lambda (uv pos val)))
    (put-s16be! (lambda (uv pos val)))
    (put-s16le! (lambda (uv pos val)))
    (put-s32be! (lambda (uv pos val)))
    (put-s32le! (lambda (uv pos val)))
    (put-s64be! (lambda (uv pos val)))
    (put-s64le! (lambda (uv pos val)))
    (put-f16be! (lambda (uv pos val)))
    (put-f16le! (lambda (uv pos val)))
    (put-f32be! (lambda (uv pos val)))
    (put-f32le! (lambda (uv pos val)))
    (put-f64be! (lambda (uv pos val)))
    (put-f64le! (lambda (uv pos val)))
    (pack (lambda (template list :key (:output) (:to-string\?))))
    (unpack (lambda (template :key (:input) (:from-string))))
    (unpack-skip (lambda (template :key (:input))))
    (make-packer (lambda (template)))
    (job\? (lambda (obj)))
    (job-status (lambda (job)))
    (job-result (lambda (job)))
    (job-wait (lambda (job :optional timeout timeout-val)))
    (job-acknowledge-time (lambda (job)))
    (job-start-time (lambda (job)))
    (job-finish-time (lambda (job)))
    (make-thread-pool (lambda (size :optional \(max-backlog\ 0\))))
    (add-job! (lambda (pool thunk :optional need-result)))
    (wait-all (lambda (pool :optional)))
    (terminate-all! (lambda (pool :key (force-timeout))))
    (bcrypt-hashpw (lambda (password :optional setting)))
    (bcrypt-gensalt (lambda (&key prefix count entropy-source)))
    (dbi-connect (lambda (dsn :key (username) (password))))
    (dbi-list-drivers (lambda nil))
    (dbi-make-driver (lambda (driver-name)))
    (dbi-parse-dsn (lambda (data-source-name)))
    (dbi-prepare-sql (lambda (connection sql)))
    (dbm-type->class (lambda (dbmtype)))
    (gdbm-open (lambda (path :optional size rwmode fmode error-callback)))
    (gdbm-close (lambda (gdbm-object)))
    (gdbm-closed\? (lambda (gdbm-object)))
    (gdbm-store (lambda (key value :optional flag)))
    (gdbm-fetch (lambda (gdbm-object key)))
    (gdbm-delete (lambda (gdbm-object key)))
    (gdbm-firstkey (lambda (gdbm-object)))
    (gdbm-nextkey (lambda (gdbm-object key)))
    (gdbm-reorganize (lambda (gdbm-object)))
    (gdbm-sync (lambda (gdbm-object)))
    (gdbm-exists\? (lambda (gdbm-object key)))
    (gdbm-strerror (lambda (errno)))
    (gdbm-setopt (lambda (gdbm-object option value)))
    (gdbm-version (lambda nil))
    (gdbm-errno (lambda nil))
    (ndbm-open (lambda (path flags mode)))
    (ndbm-close (lambda (ndbm-object)))
    (ndbm-closed\? (lambda (ndbm-object)))
    (ndbm-store (lambda (ndbm-object key content :optional flag)))
    (ndbm-fetch (lambda (ndbm-object key)))
    (ndbm-delete (lambda (ndbm-object key)))
    (ndbm-firstkey (lambda (ndbm-object)))
    (ndbm-nextkey (lambda (ndbm-object)))
    (ndbm-error (lambda (ndbm-object)))
    (ndbm-clear-error (lambda (ndbm-object)))
    (odbm-init (lambda (path)))
    (odbm-close (lambda nil))
    (odbm-store (lambda (key value)))
    (odbm-fetch (lambda (key)))
    (odbm-delete (lambda (key)))
    (odbm-firstkey (lambda nil))
    (odbm-nextkey (lambda (key)))
    (file-filter (lambda (proc :key (input) (output) (temporary-file) (keep-output\?))))
    (current-directory (lambda (:optional new-directory)))
    (home-directory (lambda (:optional user)))
    (directory-list (lambda (path :key (children\?) (add-path\?) (filter) (filter-add-path\?))))
    (directory-list2 (lambda (path :key (children\?) (add-path\?) (filter) (follow-link\?))))
    (directory-fold (lambda (path proc seed :key (lister) (follow-link\?))))
    (make-directory* (lambda (name :optional perm)))
    (create-directory* (lambda (name :optional perm)))
    (remove-directory* (lambda (name)))
    (delete-directory* (lambda (name)))
    (copy-directory* (lambda (src dst :key (if-exists) (backup-suffix) (safe) (keep-timestamp) (keep-mode) (follow-link\?))))
    (create-directory-tree (lambda (dir spec)))
    (check-directory-tree (lambda (dir spec)))
    (build-path (lambda (base-path component \.\.\.)))
    (absolute-path\? (lambda (path)))
    (relative-path\? (lambda (path)))
    (expand-path (lambda (path)))
    (resolve-path (lambda (path)))
    (simplify-path (lambda (path)))
    (decompose-path (lambda (path)))
    (path-extension (lambda (path)))
    (path-sans-extension (lambda (path)))
    (path-swap-extension (lambda (path newext)))
    (find-file-in-paths (lambda (name :key (paths) (pred))))
    (null-device (lambda nil))
    (console-device (lambda nil))
    (file-type (lambda (path :key (follow-link\?))))
    (file-perm (lambda (path :key (follow-link\?))))
    (file-mode (lambda (path :key (follow-link\?))))
    (file-ino (lambda (path :key (follow-link\?))))
    (file-dev (lambda (path :key (follow-link\?))))
    (file-rdev (lambda (path :key (follow-link\?))))
    (file-nlink (lambda (path :key (follow-link\?))))
    (file-uid (lambda (path :key (follow-link\?))))
    (file-gid (lambda (path :key (follow-link\?))))
    (file-size (lambda (path :key (follow-link\?))))
    (file-atime (lambda (path :key (follow-link\?))))
    (file-mtime (lambda (path :key (follow-link\?))))
    (file-ctime (lambda (path :key (follow-link\?))))
    (file-is-readable\? (lambda (path)))
    (file-is-writable\? (lambda (path)))
    (file-is-executable\? (lambda (path)))
    (file-is-symlink\? (lambda (path)))
    (file-eq\? (lambda (path1 path2)))
    (file-eqv\? (lambda (path1 path2)))
    (file-equal\? (lambda (path1 path2)))
    (touch-file (lambda (path)))
    (touch-files (lambda (paths)))
    (copy-file (lambda (src dst :key (if-exists) (backup-suffix) (safe) (keep-timestamp) (keep-mode) (follow-link\?))))
    (move-file (lambda (src dst :key (if-exists) (backup-suffix))))
    (remove-files (lambda (paths)))
    (delete-files (lambda (paths)))
    (file->string (lambda (filename options \.\.\.)))
    (file->list (lambda (reader filename options \.\.\.)))
    (file->string-list (lambda (filename options \.\.\.)))
    (file->sexp-list (lambda (filename options \.\.\.)))
    (mt-random-set-seed! (lambda (mt seed)))
    (mt-random-get-state (lambda (mt)))
    (mt-random-set-state! (lambda (mt state)))
    (mt-random-real (lambda (mt)))
    (mt-random-real0 (lambda (mt)))
    (mt-random-integer (lambda (mt range)))
    (mt-random-fill-u32vector! (lambda (mt u32vector)))
    (mt-random-fill-f32vector! (lambda (mt f32vector)))
    (mt-random-fill-f64vector! (lambda (mt f64vector)))
    (sys-message-box (lambda (window message :optional caption flags)))
    (sys-alloc-console (lambda nil))
    (sys-free-console (lambda nil))
    (sys-generate-console-ctrl-event (lambda (event pgid)))
    (sys-get-console-cp (lambda nil))
    (sys-get-console-output-cp (lambda nil))
    (sys-set-console-cp (lambda (codepage)))
    (sys-set-console-output-cp (lambda (codepage)))
    (sys-get-console-cursor-info (lambda (handle)))
    (sys-set-console-cursor-info (lambda (handle size visible)))
    (sys-set-console-cursor-position (lambda (handle x y)))
    (sys-get-console-mode (lambda (handle)))
    (sys-set-console-mode (lambda (handle mode)))
    (sys-create-console-screen-buffer (lambda (desired-access share-mode inheritable)))
    (sys-set-console-active-screen-buffer (lambda (handle)))
    (sys-scroll-console-screen-buffer (lambda (handle scroll-rectangle clip-rectangle x y fill)))
    (sys-get-console-screen-buffer-info (lambda (handle)))
    (sys-get-largest-console-window-size (lambda (handle)))
    (sys-set-screen-buffer-size (lambda (handle x y)))
    (sys-get-number-of-console-input-events (lambda (handle)))
    (sys-get-number-of-console-mouse-buttons (lambda nil))
    (sys-peek-console-input (lambda (handle)))
    (sys-read-console-input (lambda (handle)))
    (sys-read-console (lambda (handle buf)))
    (sys-read-console-output (lambda (handle buf w h x y region)))
    (sys-read-console-output-attribute (lambda (handle buf x y)))
    (sys-read-console-output-character (lambda (handle len x y)))
    (sys-set-console-text-attribute (lambda (handle attr)))
    (sys-set-console-window-info (lambda (handle absolute window)))
    (sys-write-console (lambda (handle string)))
    (sys-write-console-output-character (lambda (handle string x y)))
    (sys-get-console-title (lambda nil))
    (sys-get-std-handle (lambda (which)))
    (sys-set-std-handle (lambda (which handle)))
    (rfc822-read-headers (lambda (iport :key (strict\?) (reader))))
    (rfc822-header->list (lambda (iport :key (strict\?) (reader))))
    (rfc822-header-ref (lambda (header-list field-name :optional default)))
    (rfc822-next-token (lambda (iport :optional tokenizer-specs)))
    (rfc822-field->tokens (lambda (field :optional tokenizer-specs)))
    (rfc822-skip-cfws (lambda (iport)))
    (rfc822-atom (lambda (iport)))
    (rfc822-dot-atom (lambda (iport)))
    (rfc822-quoted-string (lambda (iport)))
    (rfc822-parse-date (lambda (string)))
    (rfc822-date->date (lambda (string)))
    (rfc822-write-headers (lambda (headers :key (output) (continue) (check))))
    (date->rfc822-date (lambda (date)))
    (base64-encode (lambda (:key (line-width))))
    (base64-encode-string (lambda (string :key (line-width))))
    (base64-decode (lambda nil))
    (base64-decode-string (lambda (string)))
    (parse-cookie-string (lambda (string :optional version)))
    (construct-cookie-string (lambda (specs :optional version)))
    (call-with-ftp-connection (lambda (host proc :key (passive) (port) (username) (password) (account) (log-drain))))
    (ftp-transfer-type (lambda (conn)))
    (ftp-passive\? (lambda (conn)))
    (ftp-login (lambda (host :key (passive) (port) (username) (password) (account) (log-drain))))
    (ftp-quit (lambda (conn)))
    (ftp-chdir (lambda (conn dirname)))
    (ftp-remove (lambda (conn path)))
    (ftp-help (lambda (conn :optional option \.\.\.)))
    (ftp-mkdir (lambda (conn dirname)))
    (ftp-current-directory (lambda (conn)))
    (ftp-site (lambda (conn arg)))
    (ftp-rmdir (lambda (conn dirname)))
    (ftp-stat (lambda (conn :optional pathname)))
    (ftp-system (lambda (conn)))
    (ftp-size (lambda (conn path)))
    (ftp-mdtm (lambda (conn path)))
    (ftp-mtime (lambda (conn path :optional local-time\?)))
    (ftp-noop (lambda (conn)))
    (ftp-list (lambda (conn :optional path)))
    (ftp-get (lambda (conn path :key (sink) (flusher))))
    (ftp-put (lambda (conn from-file :optional to-file)))
    (ftp-put-unique (lambda (conn from-file)))
    (ftp-rename (lambda (conn from-name to-name)))
    (http-get (lambda (server request-uri :key (sink) (flusher) (no-redirect) (secure) (\.\.\.))))
    (http-head (lambda (server request-uri :key (no-redirect) (secure) (\.\.\.))))
    (http-post (lambda (server request-uri body :key (sink) (flusher) (no-redirect) (secure) (\.\.\.))))
    (http-put (lambda (server request-uri body :key (sink) (flusher) (secure) (\.\.\.))))
    (http-delete (lambda (server request-uri :key (sink) (flusher) (secure) (\.\.\.))))
    (http-compose-query (lambda (path params :optional encoding)))
    (http-compose-form-data (lambda (params port :optional encoding)))
    (http-secure-connection-available\? (lambda nil))
    (ip-version (lambda (packet offset)))
    (ip-header-length (lambda (packet offset)))
    (ip-protocol (lambda (packet offset)))
    (ip-source-address (lambda (packet offset)))
    (ip-destination-address (lambda (packet offset)))
    (icmp4-fill-echo! (lambda (buffer ident sequence data)))
    (icmp4-fill-checksum! (lambda (buffer size)))
    (icmp6-fill-echo! (lambda (buffer ident sequence data)))
    (icmp-packet-type (lambda (buffer offset)))
    (icmp-packet-code (lambda (buffer offset)))
    (icmp-packet-ident (lambda (buffer offset)))
    (icmp-packet-sequence (lambda (buffer offsetj)))
    (icmp4-describe-packet (lambda (buffer offset)))
    (icmp6-describe-packet (lambda (buffer offset)))
    (icmp4-message-type->string (lambda (type)))
    (icmp4-unreach-code->string (lambda (code)))
    (icmp4-redirect-code->string (lambda (code)))
    (icmp4-router-code->string (lambda (code)))
    (icmp4-exceeded-code->string (lambda (code)))
    (icmp4-parameter-code->string (lambda (code)))
    (icmp4-security-code->string (lambda (code)))
    (icmp6-message-type->string (lambda (type)))
    (icmp6-unreach-code->string (lambda (code)))
    (icmp6-exceeded-code->string (lambda (code)))
    (icmp6-parameter-code->string (lambda (code)))
    (parse-json (lambda (:optional input-port)))
    (parse-json-string (lambda (str)))
    (construct-json (lambda (obj)))
    (construct-json-string (lambda (obj)))
    (md5-digest (lambda nil))
    (md5-digest-string (lambda (string)))
    (mime-parse-version (lambda (field)))
    (mime-parse-content-type (lambda (field)))
    (mime-parse-content-disposition (lambda (field)))
    (mime-parse-parameters (lambda (:optional iport)))
    (mime-compose-parameters (lambda (params :optional oport &key start-column)))
    (mime-decode-word (lambda (word)))
    (mime-decode-text (lambda (text)))
    (mime-encode-word (lambda (word :key (charset) (transfer-encoding))))
    (mime-encode-text (lambda (text :key (charset) (transfer-encoding) (line-width) (start-column) (force))))
    (mime-parse-message (lambda (port headers handler)))
    (mime-retrieve-body (lambda (part-info xport outp)))
    (mime-body->string (lambda (part-info xport)))
    (mime-body->file (lambda (part-info xport filename)))
    (mime-compose-message (lambda (parts :optional port &key boundary)))
    (mime-compose-message-string (lambda (parts &key boundary)))
    (mime-make-boundary (lambda nil))
    (quoted-printable-encode (lambda (:key (line-width) (binary))))
    (quoted-printable-encode-string (lambda (string :key (line-width) (binary))))
    (quoted-printable-decode (lambda nil))
    (quoted-printable-decode-string (lambda (string)))
    (sha1-digest (lambda nil))
    (sha224-digest (lambda nil))
    (sha256-digest (lambda nil))
    (sha384-digest (lambda nil))
    (sha512-digest (lambda nil))
    (sha1-digest-string (lambda (string)))
    (sha224-digest-string (lambda (string)))
    (sha256-digest-string (lambda (string)))
    (sha384-digest-string (lambda (string)))
    (sha512-digest-string (lambda (string)))
    (uri-parse (lambda (uri)))
    (uri-scheme&specific (lambda (uri)))
    (uri-decompose-hierarchical (lambda (specific)))
    (uri-decompose-authority (lambda (authority)))
    (uri-compose (lambda (:key (scheme) (userinfo) (host) (port) (authority) (path) (path*) (query) (fragment) (specific))))
    (uri-decode (lambda (:key (:cgi-decode))))
    (uri-decode-string (lambda (string :key (:cgi-decode) (:encoding))))
    (uri-encode (lambda (:key (:noescape))))
    (uri-encode-string (lambda (string :key (:noescape) (:encoding))))
    (open-deflating-port (lambda (drain :key (compression-level) (buffer-size) (window-bits) (memory-level) (strategy) (dictionary) (owner\?))))
    (open-inflating-port (lambda (source :key (buffer-size) (window-bits) (dictionary) (owner\?))))
    (zstream-total-in (lambda (xflating-port)))
    (zstream-total-out (lambda (xflating-port)))
    (zstream-adler32 (lambda (xflating-port)))
    (zstream-data-type (lambda (xflating-port)))
    (zstream-params-set! (lambda (deflating-port :key (compression-level) (strategy))))
    (zstream-dictionary-adler32 (lambda (deflating-port)))
    (deflating-port-full-flush (lambda (deflating-port)))
    (inflate-sync (lambda (inflating-port)))
    (zlib-version (lambda nil))
    (deflate-string (lambda (string options \.\.\.)))
    (inflate-string (lambda (string options \.\.\.)))
    (gzip-encode-string (lambda (string options \.\.\.)))
    (gzip-decode-string (lambda (string options \.\.\.)))
    (crc32 (lambda (string :optional checksum)))
    (alder32 (lambda (string :optional checksum)))
    (make-empty-attlist (lambda nil))
    (attlist-add (lambda (attlist name-value)))
    (attlist-null\? (lambda nil))
    (attlist-remove-top (lambda (attlist)))
    (attlist->alist (lambda (attlist)))
    (attlist-fold (lambda nil))
    (make-xml-token (lambda (kind head)))
    (xml-token\? (lambda (token)))
    (xml-token-kind (syntax (token)))
    (xml-token-head (syntax (token)))
    (ssax:skip-S (lambda (port)))
    (ssax:ncname-starting-char\? (lambda (a-char)))
    (ssax:read-NCName (lambda (port)))
    (ssax:read-QName (lambda (port)))
    (ssax:read-markup-token (lambda (port)))
    (ssax:skip-pi (lambda (port)))
    (ssax:read-pi-body-as-string (lambda (port)))
    (ssax:skip-internal-dtd (lambda (port)))
    (ssax:read-cdata-body (lambda (port str-handler seed)))
    (ssax:read-char-ref (lambda (port)))
    (ssax:handle-parsed-entity (lambda (port name entities content-handler str-handler seed)))
    (ssax:read-attributes (lambda (port entities)))
    (ssax:resolve-name (lambda (port unres-name namespaces apply-default-ns\?)))
    (ssax:uri-string->symbol (lambda (uri-str)))
    (ssax:complete-start-tag (lambda (tag port elems entities namespaces)))
    (ssax:read-external-id (lambda (port)))
    (ssax:scan-Misc (lambda (port)))
    (ssax:read-char-data (lambda (port expect-eof\? str-handler seed)))
    (ssax:assert-token (lambda (token kind gi error-cont)))
    (ssax:make-pi-parser (syntax (my-pi-handlers)))
    (ssax:make-elem-parser (syntax (my-new-level-seed my-finish-element my-char-data-handler my-pi-handlers)))
    (ssax:make-parser (syntax (user-handler-tag user-handler-proc \\\.\\\.\\\.)))
    (ssax:reverse-collect-str (lambda (fragments)))
    (ssax:reverse-collect-str-drop-ws (lambda (fragments)))
    (ssax:xml->sxml (lambda (port namespace-prefix-assig)))
    (nodeset\? (lambda (x)))
    (as-nodeset (lambda (x)))
    (sxml:element\? (lambda (obj)))
    (ntype-names\?\? (lambda (crit)))
    (ntype\?\? (lambda (crit)))
    (ntype-namespace-id\?\? (lambda (ns-id)))
    (sxml:invert (lambda (pred)))
    (node-eq\? (lambda (other)))
    (node-equal\? (lambda (other)))
    (node-pos (lambda (n)))
    (sxml:filter (lambda (pred\?)))
    (take-until (lambda (pred\?)))
    (take-after (lambda (pred\?)))
    (map-union (lambda (proc lst)))
    (node-reverse (lambda (node-or-nodeset)))
    (node-trace (lambda (title)))
    (select-kids (lambda (test-pred\?)))
    (node-self (lambda (pred)))
    (node-join (lambda nil))
    (node-reduce (lambda nil))
    (node-or (lambda nil))
    (node-closure (lambda (test-pred\?)))
    (sxpath (lambda (abbrpath)))
    (if-sxpath (lambda (path)))
    (if-car-sxpath (lambda (path)))
    (car-sxpath (lambda (path)))
    (sxml:id-alist (lambda (node)))
    (sxml:string (lambda (object)))
    (sxml:boolean (lambda (object)))
    (sxml:number (lambda (obj)))
    (sxml:string-value (lambda (node)))
    (sxml:node\? (lambda (node)))
    (sxml:attr-list (lambda (obj)))
    (sxml:id (lambda (id-index)))
    (sxml:equality-cmp (lambda (bool-op number-op string-op)))
    (sxml:equal\? (lambda (a b)))
    (sxml:not-equal\? (lambda (a b)))
    (sxml:relational-cmp (lambda (op)))
    (sxml:attribute (lambda (test-pred\?)))
    (sxml:child (lambda (test-pred\?)))
    (sxml:parent (lambda (test-pred\?)))
    (sxml:ancestor (lambda (test-pred\?)))
    (sxml:ancestor-or-self (lambda (test-pred\?)))
    (sxml:descendant (lambda (test-pred\?)))
    (sxml:descendant-or-self (lambda (test-pred\?)))
    (sxml:following (lambda (test-pred\?)))
    (sxml:following-sibling (lambda (test-pred\?)))
    (sxml:namespace (lambda (test-pred\?)))
    (sxml:preceding (lambda (test-pred\?)))
    (sxml:preceding-sibling (lambda (test-pred\?)))
    (sxml:child-nodes (lambda (nodeset)))
    (sxml:child-elements (lambda (nodeset)))
    (sxml:empty-element\? (lambda (obj)))
    (sxml:shallow-normalized\? (lambda (obj)))
    (sxml:normalized\? (lambda (obj)))
    (sxml:shallow-minimized\? (lambda (obj)))
    (sxml:minimized\? (lambda (obj)))
    (sxml:name (lambda (obj)))
    (sxml:element-name (lambda (obj)))
    (sxml:node-name (lambda (obj)))
    (sxml:ncname (lambda (obj)))
    (sxml:name->ns-id (lambda (sxml-name)))
    (sxml:content (lambda (obj)))
    (sxml:content-raw (lambda (obj)))
    (sxml:attr-list-node (lambda (obj)))
    (sxml:attr-as-list (lambda (obj)))
    (sxml:aux-list-node (lambda (obj)))
    (sxml:aux-as-list (lambda (obj)))
    (sxml:attr-list-u (lambda (obj)))
    (sxml:aux-list (lambda (obj)))
    (sxml:aux-list-u (lambda (obj)))
    (sxml:aux-node (lambda (obj aux-name)))
    (sxml:aux-nodes (lambda (obj aux-name)))
    (sxml:attr (lambda (obj attr-name)))
    (sxml:num-attr (lambda (obj attr-name)))
    (sxml:attr-u (lambda (obj attr-name)))
    (sxml:ns-list (lambda (obj)))
    (sxml:ns-id->nodes (lambda (obj namespace-id)))
    (sxml:ns-id->uri (lambda (obj namespace-id)))
    (sxml:ns-uri->id (lambda (obj uri)))
    (sxml:ns-id (lambda (ns-assoc)))
    (sxml:ns-uri (lambda (ns-assoc)))
    (sxml:ns-prefix (lambda (ns-assoc)))
    (sxml:change-content (lambda (obj new-content)))
    (sxml:change-content! (lambda (obj new-content)))
    (sxml:change-attrlist (lambda (obj new-attrlist)))
    (sxml:change-attrlist! (lambda (obj new-attrlist)))
    (sxml:change-name (lambda (obj new-name)))
    (sxml:change-name! (lambda (obj new-name)))
    (sxml:add-attr (lambda (obj attr)))
    (sxml:add-attr! (lambda (obj attr)))
    (sxml:change-attr (lambda (obj attr)))
    (sxml:change-attr! (lambda (obj attr)))
    (sxml:set-attr (lambda (obj attr)))
    (sxml:set-attr! (lambda (obj attr)))
    (sxml:add-aux (lambda (obj aux-node)))
    (sxml:add-aux! (lambda (obj aux-node)))
    (sxml:squeeze (lambda (obj)))
    (sxml:squeeze! (lambda (obj)))
    (sxml:clean (lambda (obj)))
    (sxml:add-parents (lambda (obj)))
    (sxml:node-parent (lambda (rootnode)))
    (sxml:lookup (lambda (id index)))
    (sxml:clean-feed (lambda nil))
    (sxml:attr->xml (lambda (attr)))
    (sxml:string->xml (lambda (string)))
    (sxml:sxml->xml (lambda (tree)))
    (sxml:attr->html (lambda (attr)))
    (sxml:string->html (lambda (string)))
    (sxml:non-terminated-html-tag\? (lambda (tag)))
    (sxml:sxml->html (lambda (tree)))
    (srl:sxml->xml (lambda (sxml-obj :optional port-or-filename)))
    (srl:sxml->xml-noindent (lambda (sxml-obj :optional port-or-filename)))
    (srl:sxml->html (lambda (sxml-obj :optional port-or-filename)))
    (srl:sxml->html-noindent (lambda (sxml-obj :optional port-or-filename)))
    (srl:parameterizable (lambda (sxml-obj :optional port-or-filename params*)))
    (srl:sxml->string (lambda (sxml-obj cdata-section-elements indent method ns-prefix-assig omit-xml-declaration\? standalone version)))
    (srl:display-sxml (lambda (sxml->obj port-or-filename cdata-section-elements indent method ns-prefix-assig omit-xml-declaration\? standalone version)))
    (make-csv-reader (lambda (separator :optional)))
    (make-csv-writer (lambda (separator :optional newline)))
    (diff (lambda (src-a src-b :key (reader) (eq-fn))))
    (diff-report (lambda (src-a src-b :key (reader) (eq-fn) (writer))))
    (textdomain (lambda (domain-name :optional locale dirs cdir cached\? lookup-cached\?)))
    (gettext (lambda (msg-id)))
    (ngettext (lambda (msg-id :optional msg-id2 num)))
    (bindtextdomain (lambda (domain dirs)))
    (dgettext (lambda (domain msg-id)))
    (dcgettext (lambda (domain msg-id locale)))
    (make-gettext (lambda (:optional domain locale dirs gettext-cached\? lookup-cached\?)))
    (html-escape (lambda nil))
    (html-escape-string (lambda (string)))
    (html-doctype (lambda (:key (type))))
    (find-string-from-port\? (lambda (str in-port :optional max-no-chars)))
    (peek-next-char (lambda (:optional port)))
    (assert-curr-char (lambda (char-list string :optional port)))
    (skip-until (lambda (char-list/number :optional port)))
    (skip-while (lambda (char-list :optional port)))
    (next-token (lambda (prefix-char-list break-char-list :optional comment port)))
    (next-token-of (lambda (char-list/pred :optional port)))
    (read-string (lambda (n :optional port)))
    (make-text-progress-bar (lambda (:key (header) (header-width) (bar-char) (bar-width) (num-width) (num-format) (time-width) (info) (info-width) (separator-char) (max-value) (port))))
    (sql-tokenize (lambda (sql-string)))
    (tr (lambda (from-list to-list :key (:complement) (:delete) (:squeeze) (:table-size) (:input) (:output))))
    (string-tr (lambda (string from-list to-list :key (:complement) (:delete) (:squeeze) (:table-size))))
    (build-transliterator (lambda (from-list to-list :key (:complement) (:delete) (:squeeze) (:table-size) (:input) (:output))))
    (tree->string (lambda (tree)))
    (permutations (lambda (set)))
    (permutations* (lambda (set :optional eq)))
    (permutations-for-each (lambda (proc set)))
    (permutations*-for-each (lambda (proc set :optional eq)))
    (combinations (lambda (set n)))
    (combinations* (lambda (set n :optional eq)))
    (combinations-for-each (lambda (proc set n)))
    (combinations*-for-each (lambda (proc set n :optional eq)))
    (power-set (lambda (set)))
    (power-set* (lambda (set :optional eq)))
    (power-set-for-each (lambda (proc set)))
    (power-set*-for-each (lambda (proc set :optional eq)))
    (power-set-binary (lambda (set)))
    (cartesian-product (lambda (list-of-sets)))
    (cartesian-product-right (lambda (list-of-sets)))
    (digest-hexify (lambda (digest-result)))
    (isomorphic\? (lambda (obj1 obj2 :optional context)))
    (lcs (lambda (seq-a seq-b :optional eq-fn)))
    (lcs-with-positions (lambda (seq-a seq-b :optional eq-fn)))
    (lcs-fold (lambda (a-proc b-proc both-proc seed a b :optional eq-fn)))
    (lcs-edit-list (lambda (a b :optional eq-fn)))
    (take* (lambda (list k :optional fill\? padding)))
    (drop* (lambda (list k)))
    (take-right* (lambda (list k :optional fill\? padding)))
    (drop-right* (lambda (list k)))
    (split-at* (lambda (list k :optional fill\? padding)))
    (slices (lambda (list k :optional fill\? padding)))
    (intersperse (lambda (item list)))
    (cond-list (syntax (clause \.\.\.)))
    (alist->hash-table (lambda (alist :optional cmp)))
    (hash-table->alist (lambda (hash-table)))
    (rassoc (lambda (key alist :optional eq-fn)))
    (rassq (lambda (key alist)))
    (rassv (lambda (key alist)))
    (assoc-ref (lambda (alist key :optional default eq-fn)))
    (assq-ref (lambda (alist key :optional default)))
    (assv-ref (lambda (alist key :optional default)))
    (rassoc-ref (lambda (alist key :optional default eq-fn)))
    (rassq-ref (lambda (alist key :optional default)))
    (rassv-ref (lambda (alist key :optional default)))
    (assoc-set! (lambda (alist key val :optional eq-fn)))
    (assq-set! (lambda (alist key val)))
    (assv-set! (lambda (alist key val)))
    (match (syntax (expr clause \.\.\.)))
    (match-lambda (syntax (clause \.\.\.)))
    (match-lambda* (syntax (clause \.\.\.)))
    (match-let (syntax (\(\(pat\ expr\)\ \.\.\.\) body-expr \.\.\.)))
    (match-let (syntax (name \(\(pat\ expr\)\ \.\.\.\) body-expr \.\.\.)))
    (match-let* (syntax (\(\(pat\ expr\)\ \.\.\.\) body-expr \.\.\.)))
    (match-letrec (syntax (\(\(pat\ expr\)\ \.\.\.\) body-expr \.\.\.)))
    (match-let1 (syntax (pat expr body-expr \.\.\.)))
    (match-define (syntax (pat expr)))
    (make-queue (lambda nil))
    (make-mtqueue (lambda (&key max-length)))
    (queue\? (lambda (obj)))
    (mtqueue\? (lambda (obj)))
    (queue-empty\? (lambda (queue)))
    (queue-length (lambda (queue)))
    (mtqueue-max-length (lambda (mtqueue)))
    (mtqueue-room (lambda (mtqueue)))
    (copy-queue (lambda (queue)))
    (enqueue! (lambda (queue obj :optional more-objs \.\.\.)))
    (queue-push! (lambda (queue obj :optional more-objs \.\.\.)))
    (enqueue-unique! (lambda (queue eq-proc obj :optional more-objs \.\.\.)))
    (queue-push-unique! (lambda (queue eq-proc obj :optional more-objs \.\.\.)))
    (dequeue! (lambda (queue :optional fallback)))
    (queue-pop! (lambda (queue :optional fallback)))
    (dequeue-all! (lambda (queue)))
    (queue-front (lambda (queue :optional fallback)))
    (queue-rear (lambda (queue :optional fallback)))
    (list->queue (lambda (list :optional class :rest initargs)))
    (queue->list (lambda (queue)))
    (find-in-queue (lambda (pred queue)))
    (any-in-queue (lambda (pred queue)))
    (every-in-queue (lambda (pred queue)))
    (remove-from-queue! (lambda (pred queue)))
    (enqueue/wait! (lambda (mtqueue obj :optional timeout timeout-val)))
    (queue-push/wait! (lambda (mtqueue obj :optional timeout timeout-val)))
    (dequeue/wait! (lambda (mtqueue :optional timeout timeout-val)))
    (queue-pop/wait! (lambda (mtqueue :optional timeout timeout-val)))
    (make-rbtree (lambda (key=\? key<\?)))
    (rbtree-copy (lambda (rbtree)))
    (rbtree-empty\? (lambda (rbtree)))
    (rbtree-num-entries (lambda (rbtree)))
    (rbtree-exists\? (lambda (rbtree key)))
    (rbtree-get (lambda (rbtree key :optional fallback)))
    (rbtree-put! (lambda (rbtree key value)))
    (rbtree-delete! (lambda (rbtree key)))
    (rbtree-update! (lambda (rbtree key proc :optional fallback)))
    (rbtree-push! (lambda (rbtree key value)))
    (rbtree-pop! (lambda (rbtree key :optional fallback)))
    (rbtree-min (lambda (rbtree :optional fallback)))
    (rbtree-max (lambda (rbtree :optional fallback)))
    (rbtree-extract-min! (lambda (rbtree :optional fallback)))
    (rbtree-extract-max! (lambda (rbtree :optional fallback)))
    (rbtree-fold (lambda (rbtree proc seed)))
    (rbtree-fold-right (lambda (rbtree proc seed)))
    (rbtree-keys (lambda (rbtree)))
    (rbtree-values (lambda (rbtree)))
    (rbtree->alist (lambda (rbtree)))
    (alist->rbtree (lambda (alist key=\? key<\?)))
    (make-record-type (lambda (type-name field-names)))
    (record-constructor (lambda (rtd :optional field-names)))
    (record-predicate (lambda (rtd)))
    (record-accessor (lambda (rtd field-name)))
    (record-modifier (lambda (rtd field-name)))
    (make-sparse-vector (lambda (:optional type)))
    (sparse-vector-max-index-bits (lambda nil))
    (sparse-vector-copy (lambda (sv)))
    (sparse-vector-ref (lambda (sv k :optional default)))
    (sparse-vector-set! (lambda (sv k value)))
    (sparse-vector-num-entries (lambda (sv)))
    (sparse-vector-exists\? (lambda (sv k)))
    (sparse-vector-delete! (lambda (sv k)))
    (sparse-vector-clear! (lambda (sv)))
    (sparse-vector-inc! (lambda (sv k delta :optional \(fallback\ 0\))))
    (sparse-vector-update! (lambda (sv k proc :optional fallback)))
    (sparse-vector-push! (lambda (sv k val)))
    (sparse-vector-pop! (lambda (sv k :optional fallback)))
    (sparse-vector-fold (lambda (sv proc seed)))
    (sparse-vector-for-each (lambda (sv proc)))
    (sparse-vector-map (lambda (sv proc)))
    (sparse-vector-keys (lambda (sv)))
    (sparse-vector-values (lambda (sv)))
    (make-sparse-table (lambda (type)))
    (sparse-table-copy (lambda (st)))
    (sparse-table-num-entries (lambda (st)))
    (sparse-table-ref (lambda (st key :optional fallback)))
    (sparse-table-set! (lambda (st key value)))
    (sparse-table-exists\? (lambda (st key)))
    (sparse-table-delete! (lambda (st key)))
    (sparse-table-clear! (lambda (st)))
    (sparse-table-update! (lambda (st key proc :optional fallback)))
    (sparse-table-push! (lambda (st key val)))
    (sparse-table-pop! (lambda (st key :optional fallback)))
    (sparse-table-fold (lambda (st proc seed)))
    (sparse-table-for-each (lambda (st proc)))
    (sparse-table-map (lambda (st proc)))
    (sparse-table-keys (lambda (st)))
    (sparse-table-values (lambda (st)))
    (stream\? (lambda (obj)))
    (stream-cons (syntax (object stream)))
    (stream-null\? (lambda (obj)))
    (stream-pair\? (lambda (obj)))
    (stream-car (lambda (s)))
    (stream-cdr (lambda (s)))
    (stream-delay (syntax (expr)))
    (stream (lambda (obj \.\.\.)))
    (stream-unfoldn (lambda (generator seed n)))
    (stream-map (lambda (func)))
    (stream-for-each (lambda (func)))
    (stream-filter (lambda (pred\? stream)))
    (stream-xcons (lambda (a b)))
    (stream-cons* (lambda (elt \.\.\. stream)))
    (make-stream (lambda (n :optional init)))
    (stream-tabulate (lambda (n init-proc)))
    (stream-format (lambda (fmt arg \.\.\.)))
    (stream->list (lambda (stream)))
    (stream->string (lambda (stream)))
    (list->stream (lambda (list)))
    (string->stream (lambda (string :optional stream)))
    (port->stream (lambda (:optional iport reader closer)))
    (iterator->stream (lambda (iter)))
    (stream-lines (lambda (stream)))
    (stream= (lambda (elt= stream \.\.\.)))
    (stream-prefix= (lambda (stream prefix :optional elt=)))
    (stream-caar (lambda (s)))
    (stream-cadr (lambda (s)))
    (stream-cdddar (lambda (s)))
    (stream-cddddr (lambda (s)))
    (stream-ref (lambda (stream pos)))
    (stream-first (lambda (s)))
    (stream-second (lambda (s)))
    (stream-third (lambda (s)))
    (stream-fourth (lambda (s)))
    (stream-fifth (lambda (s)))
    (stream-sixth (lambda (s)))
    (stream-seventh (lambda (s)))
    (stream-eighth (lambda (s)))
    (stream-ninth (lambda (s)))
    (stream-tenth (lambda (s)))
    (stream-take (lambda (stream count)))
    (stream-take-safe (lambda (stream count)))
    (stream-drop (lambda (stream count)))
    (stream-drop-safe (lambda (stream count)))
    (stream-intersperse (lambda (stream element)))
    (stream-split (lambda (stream pred)))
    (stream-last (lambda (stream)))
    (stream-last-n (lambda (stream count)))
    (stream-butlast (lambda (stream)))
    (stream-butlast-n (lambda (stream count)))
    (stream-length (lambda (stream)))
    (stream-length>= (lambda (stream n)))
    (stream-append (lambda (stream \.\.\.)))
    (stream-concatenate (lambda (streams)))
    (stream-reverse (lambda (stream :optional tail-stream)))
    (stream-count (lambda (pred stream \.\.\.)))
    (stream-remove (lambda (pred stream)))
    (stream-partition (lambda (pred stream)))
    (stream-find (lambda (pred stream)))
    (stream-find-tail (lambda (pred stream)))
    (stream-take-while (lambda (pred stream)))
    (stream-drop-while (lambda (pred stream)))
    (stream-span (lambda (pred stream)))
    (stream-break (lambda (pred stream)))
    (stream-any (lambda (pred stream \.\.\.)))
    (stream-every (lambda (pred stream \.\.\.)))
    (stream-index (lambda (pred stream \.\.\.)))
    (stream-member (lambda (obj stream :optional elt=)))
    (stream-memq (lambda (obj stream)))
    (stream-memv (lambda (obj stream)))
    (stream-delete (lambda (obj stream :optional elt=)))
    (stream-delete-duplicates (lambda (stream :optional elt=)))
    (stream-grep (lambda (re stream)))
    (write-stream (lambda (stream :optional oport writer)))
    (make-trie (lambda (:optional tab-make tab-get tab-put! tab-fold)))
    (trie (lambda (params kv \.\.\.)))
    (trie-with-keys (lambda (params key \.\.\.)))
    (trie\? (lambda (obj)))
    (trie-num-entries (lambda (trie)))
    (trie-exists\? (lambda (trie key)))
    (trie-get (lambda (trie key :optional fallback)))
    (trie-put! (lambda (trie key value)))
    (trie-update! (lambda (trie key proc :optional fallback)))
    (trie-delete! (lambda (trie key)))
    (trie->list (lambda (trie)))
    (trie-keys (lambda (trie)))
    (trie-values (lambda (trie)))
    (trie->hash-table (lambda (trie ht-type)))
    (trie-common-prefix (lambda (trie prefix)))
    (trie-common-prefix-keys (lambda (trie prefix)))
    (trie-common-prefix-values (lambda (trie prefix)))
    (trie-common-prefix-fold (lambda (trie prefix proc seed)))
    (trie-common-prefix-map (lambda (trie prefix proc)))
    (trie-common-prefix-for-each (lambda (trie prefix proc)))
    (trie-fold (lambda (trie proc seed)))
    (trie-map (lambda (trie proc)))
    (trie-for-each (lambda (trie proc)))
    (topological-sort (lambda (graph :optional eqproc)))
    (cgi-get-metavariable (lambda (name)))
    (cgi-parse-parameters (lambda (:key (:query-string) (:merge-cookies) (:part-handlers))))
    (cgi-get-parameter (lambda (name params :key (:default) (:list) (:convert))))
    (cgi-header (lambda (:key (status) (content-type) (location) (cookies))))
    (cgi-main (lambda (proc :key (on-error) (merge-cookies) (output-proc) (part-handlers))))
    (cgi-add-temporary-file (lambda (filename)))
    (cgi-test-enviornment-ref (lambda (envvar-name)))
    (call-with-cgi-script (lambda (script proc :key (\(environment\ nil\)))))
    (run-cgi-script->header&body (lambda (script reader :key (environment) (parameters))))
    (run-cgi-script->sxml (lambda (script :key (environment) (parameters))))
    (run-cgi-script->string (lambda (script :key (environment) (parameters))))
    (run-cgi-script->string-list (lambda (script :key (environment) (parameters))))
    (object-equal\? (lambda (obj1 obj2)))
    (x->number (lambda (obj)))
    (x->integer (lambda (obj)))
    (default-endian (lambda nil))
    (x->string (lambda (obj)))
    (object-hash (lambda (obj)))
    (ref (lambda (\(ht\ <hash-table>\) key :optional default)))
    (ref (lambda (object key :optional args \.\.\.)))
    (object-apply (lambda (object arg \.\.\.)))
    (write-object (lambda (\(obj\ <object>\) port)))
    (object-compare (lambda (obj1 obj2)))
    (debug-print-width (lambda nil))
    (make (lambda nil))
    (make (lambda (\(class\ <class>\) arg \.\.\.)))
    (allocate-instance (lambda nil))
    (allocate-instance (lambda (\(class\ <class>\) initargs)))
    (initialize (lambda nil))
    (initialize (lambda (\(obj\ <object>\) initargs)))
    (ref (lambda (\(obj\ <object>\) \(slot\ <symbol>\))))
    (slot-unbound (lambda nil))
    (slot-unbound (lambda (\(class\ <class>\) obj slot)))
    (slot-missing (lambda nil))
    (slot-missing (lambda (\(class\ <class>\) obj slot :optional value)))
    (slot-ref-using-class (lambda (\(class\ <class>\) \(obj\ <object>\) slot-name)))
    (slot-set-using-class! (lambda (\(class\ <class>\) \(obj\ <object>\) slot-name value)))
    (slot-bound-using-class\? (lambda (\(class\ <class>\) \(obj\ <object>\) slot-name)))
    (change-class (lambda nil))
    (change-class (lambda (\(obj\ <object>\) \(new-class\ <class>\))))
    (next-method (lambda nil))
    (next-method (lambda (args \.\.\.)))
    (make (lambda (\(class\ <class>\) :rest initargs)))
    (compute-slots (lambda nil))
    (compute-get-n-set (lambda nil))
    (compute-slot-accessor (lambda nil))
    (compute-slot-accessor (lambda (\(class\ <class>\) slot access-specifier)))
    (compute-slots (lambda (\(class\ <class>\))))
    (compute-get-n-set (lambda (\(class\ <class>\) slot)))
    (make (lambda (\(class\ <method>\) :rest initargs)))
    (apply-generic (lambda (gf args)))
    (sort-applicable-methods (lambda (gf methods args)))
    (method-more-specific\? (lambda (method1 method2 classes)))
    (apply-methods (lambda (gf methods args)))
    (apply-method (lambda (gf method build-next args)))
    (fold (lambda (proc knil coll coll2 \.\.\.)))
    (fold2 (lambda (proc knil1 knil2 coll coll2 \.\.\.)))
    (fold3 (lambda (proc knil1 knil2 knil3 coll coll2 \.\.\.)))
    (map (lambda (proc coll coll2 \.\.\.)))
    (map-to (lambda (class proc coll coll2 \.\.\.)))
    (map-accum (lambda (proc seed coll1 coll2 \.\.\.)))
    (for-each (lambda (proc coll coll2 \.\.\.)))
    (fold$ (lambda (proc)))
    (fold$ (lambda (proc knil)))
    (map$ (lambda (proc)))
    (for-each$ (lambda (proc)))
    (find (lambda (pred coll)))
    (find-min (lambda (coll :key (key) (compare) (default))))
    (find-max (lambda (coll :key (key) (compare) (default))))
    (find-min&max (lambda (coll :key (key) (compare) (default) (default-min) (default-max))))
    (filter (lambda (pred coll)))
    (filter-to (lambda (class pred coll)))
    (remove (lambda (pred coll)))
    (remove-to (lambda (class pred coll)))
    (partition (lambda (pred coll)))
    (partition-to (lambda (class pred coll)))
    (group-collection (lambda (coll :key (key) (test))))
    (size-of (lambda (coll)))
    (lazy-size-of (lambda (coll)))
    (coerce-to (lambda (class coll)))
    (call-with-iterator (lambda (collection proc :key (start))))
    (with-iterator (lambda (\(collection\ end\?\ next\ args\ \.\.\.\) body \.\.\.)))
    (call-with-builder (lambda (collection-class proc :key (size))))
    (with-builder (lambda (\(collection\ add!\ get\ args\ \.\.\.\) body \.\.\.)))
    (dict-get (lambda (\(dict\ <dictionary>\) key :optional default)))
    (dict-put! (lambda (\(dict\ <dictionary>\) key value)))
    (dict-exists\? (lambda (\(dict\ <dictionary>\) key)))
    (dict-delete! (lambda (\(dict\ <dictionary>\) key)))
    (dict-fold (lambda (\(dict\ <dictionary>\) proc seed)))
    (dict-fold-right (lambda (\(dict\ <ordered-dictionary>\) proc seed)))
    (dict-for-each (lambda (\(dict\ <dictionary>\) proc)))
    (dict-map (lambda (\(dict\ <dictionary>\) proc)))
    (dict-keys (lambda (\(dict\ <dictionary>\))))
    (dict-values (lambda (\(dict\ <dictionary>\))))
    (add-hook! (lambda (\(hook\ <hook>\) proc :optional)))
    (delete-hook! (lambda (\(hook\ <hook>\) proc)))
    (remove-hook! (lambda (\(hook\ <hook>\) proc)))
    (reset-hook! (lambda (\(hook\ <hook>\))))
    (hook->list (lambda (\(hook\ <hook>\))))
    (run-hook (lambda (\(hook\ <hook>\) arg \.\.\.)))
    (describe (lambda (obj)))
    (d (lambda (obj)))
    (listener-read-handler (lambda (\(listener\ <listener>\))))
    (listener-show-prompt (lambda (\(listener\ <listener>\))))
    (log-default-drain (lambda nil))
    (log-format (lambda (\(format\ <string>\) arg \.\.\.)))
    (log-format (lambda (\(drain\ <log-drain>\) \(format\ <string>\) arg \.\.\.)))
    (instance-of (lambda (\(class\ <singleton-meta>\) :rest initargs)))
    (sockaddr-family (lambda (addr)))
    (sockaddr-name (lambda (addr)))
    (sockaddr-family (lambda (\(addr\ <sockaddr-in>\))))
    (sockaddr-name (lambda (\(addr\ <sockaddr-in>\))))
    (sockaddr-addr (lambda (\(addr\ <sockaddr-in>\))))
    (sockaddr-port (lambda (\(addr\ <sockaddr-in>\))))
    (sockaddr-family (lambda (\(addr\ <sockaddr-un>\))))
    (sockaddr-name (lambda (\(addr\ <sockaddr-un>\))))
    (parameter-observer-add! (lambda (\(p\ <parameter>\) proc :optional when where)))
    (parameter-observer-delete! (lambda (\(p\ <parameter>\) proc :optional when)))
    (parameter-pre-observers (lambda (\(p\ <parameter>\))))
    (parameter-post-observers (lambda (\(p\ <parameter>\))))
    (process-pid (lambda (\(process\ <process>\))))
    (process-command (lambda (\(process\ <process>\))))
    (process-input (lambda (\(process\ <process>\) :optional name)))
    (process-output (lambda (\(process\ <process>\) :optional name)))
    (process-error (lambda (\(process\ <process>\))))
    (selector-add! (lambda (\(self\ <selector>\) port-or-fd proc flags)))
    (selector-delete! (lambda (\(self\ <selector>\) port-or-fd proc flags)))
    (selector-select (lambda (\(self\ <selector>\) :optional)))
    (ref (lambda (\(seq\ <sequence>\) index :optional fallback)))
    (referencer (lambda (\(seq\ <sequence>\))))
    (modifier (lambda (\(seq\ <sequence>\))))
    (subseq (lambda (\(seq\ <sequence>\) :optional start end)))
    (fold-with-index (lambda (kons knil \(seq\ <sequence>\) \.\.\.)))
    (map-with-index (lambda (proc \(seq\ <sequence>\) \.\.\.)))
    (map-to-with-index (lambda (class proc \(seq\ <sequence>\) \.\.\.)))
    (for-each-with-index (lambda (proc \(seq\ <sequence>\) \.\.\.)))
    (find-with-index (lambda (pred \(seq\ <sequence>\))))
    (find-index (lambda (pred \(seq\ <sequence>\))))
    (fold-right (lambda (kons knil \(seq\ <sequence>\) \.\.\.)))
    (group-sequence (lambda (seq :key (key) (test))))
    (permute (lambda (\(src\ <sequence>\) \(permuter\ <sequence>\) :optional fallback)))
    (permute-to (lambda (\(class\ <class>\) \(src\ <sequence>\) \(permuter\ <sequence>\) :optional fallback)))
    (permute! (lambda (\(src\ <sequence>\) \(permuter\ <sequence>\) :optional fallback)))
    (shuffle (lambda (\(src\ <sequence>\) :optional random-source)))
    (shuffle-to (lambda (\(class\ <class>\) \(src\ <sequence>\) :optional random-source)))
    (shuffle! (lambda (\(src\ <sequence>\) :optional random-source)))
    (time-counter-start! (lambda (\(counter\ <time-counter>\))))
    (time-counter-stop! (lambda (\(counter\ <time-counter>\))))
    (time-counter-reset! (lambda (\(counter\ <time-counter>\))))
    (time-counter-value (lambda (\(counter\ <time-counter>\))))
    (program (lambda (program-clause program-clause2 \.\.\.)))
    (requires (lambda (feature-id feature-id2 \.\.\.)))
    (files (lambda (filename \.\.\.)))
    (code (lambda (scheme-expression \.\.\.)))
    (feature-cond (lambda (clause clause2 \.\.\.)))
    (current-language (lambda nil))
    (current-country (lambda nil))
    (current-locale-details (lambda nil))
    (dbi-open\? (lambda (\(c\ <dbi-connection>\))))
    (dbi-close (lambda (\(c\ <dbi-connection>\))))
    (dbi-prepare (lambda (conn sql :key (pass-through) (\.\.\.))))
    (dbi-open\? (lambda (\(q\ <dbi-query>\))))
    (dbi-close (lambda (\(q\ <dbi-query>\))))
    (dbi-execute (lambda (\(q\ <dbi-query>\) parameter \.\.\.)))
    (dbi-do (lambda (conn sql :optional options parameter-value \.\.\.)))
    (dbi-escape-sql (lambda (conn str)))
    (dbi-open\? (lambda (result)))
    (dbi-close (lambda (result)))
    (dbi-make-connection (lambda (\(d\ <foo-driver>\) \(options\ <string>\) \(option-alist\ <list>\) :key (username) (password) (\.\.\.))))
    (dbi-prepare (lambda (\(c\ <foo-connection>\) \(sql\ <string>\) :key (pass-through) (\.\.\.))))
    (dbi-execute-using-connection (lambda (\(c\ <foo-connection>\) \(q\ <dbi-query>\) \(params\ <list>\))))
    (dbi-escape-sql (lambda (\(c\ <foo-connection>\) str)))
    (dbi-open\? (lambda (\(c\ <foo-connection>\))))
    (dbi-open\? (lambda (\(q\ <foo-query>\))))
    (dbi-open\? (lambda (\(r\ <foo-result>\))))
    (dbi-close (lambda (\(c\ <foo-connection>\))))
    (dbi-close (lambda (\(q\ <foo-query>\))))
    (dbi-close (lambda (\(r\ <foo-result>\))))
    (dbi-do (lambda (\(c\ <foo-connection>\) \(sql\ <string>\) :optional options parameter-value \.\.\.)))
    (dbm-open (lambda (\(dbm\ <dbm>\))))
    (dbm-open (lambda (\(dbm-class\ <dbm-meta>\) options \.\.\.)))
    (dbm-close (lambda (\(dbm\ <dbm>\))))
    (dbm-closed\? (lambda (\(dbm\ <dbm>\))))
    (dbm-put! (lambda (\(dbm\ <dbm>\) key value)))
    (dbm-get (lambda (\(dbm\ <dbm>\) key :optional default)))
    (dbm-exists\? (lambda (\(dbm\ <dbm>\) key)))
    (dbm-delete! (lambda (\(dbm\ <dbm>\) key)))
    (dbm-fold (lambda (\(dbm\ <dbm>\) procedure knil)))
    (dbm-for-each (lambda (\(dbm\ <dbm>\) procedure)))
    (dbm-map (lambda (\(dbm\ <dbm>\) procedure)))
    (dbm-db-exists\? (lambda (class name)))
    (dbm-db-remove (lambda (class name)))
    (dbm-db-copy (lambda (class from to)))
    (dbm-db-move (lambda (class from to)))
    (temporary-directory (lambda nil))
    (file-mtime=\? (lambda (f1 f2)))
    (file-mtime<\? (lambda (f1 f2)))
    (file-mtime<=\? (lambda (f1 f2)))
    (file-mtime>\? (lambda (f1 f2)))
    (file-mtime>=\? (lambda (f1 f2)))
    (file-ctime=\? (lambda (f1 f2)))
    (file-atime=\? (lambda (f1 f2)))
    (hmac-update! (lambda (\(hmac\ <hmac>\) data)))
    (hmac-final! (lambda (\(hmac\ <hmac>\))))
    (hmac-digest (lambda (:key (key) (hasher))))
    (hmac-digest-string (lambda (string :key (key) (hasher))))
    (http-user-agent (lambda (:optional value)))
    (<sql-parse-error> (lambda nil))
    (write-tree (lambda (tree :optional out)))
    (write-tree (lambda (\(\(tree\ <list>\)\ out\))))
    (write-tree (lambda (\(\(tree\ <top>\)\ out\))))
    (digest-update! (lambda (algorithm data)))
    (digest-final! (lambda (algorithm)))
    (digest (lambda (class)))
    (digest-string (lambda (class string)))
    (object-isomorphic\? (lambda (obj1 obj2 context)))
    (relation-column-names (lambda (\(r\ <relation>\))))
    (relation-accessor (lambda (\(r\ <relation>\))))
    (relation-modifier (lambda (\(r\ <relation>\))))
    (relation-rows (lambda (\(r\ <relation>\))))
    (relation-column-name\? (lambda (\(r\ <relation>\) column)))
    (relation-column-getter (lambda (\(r\ <relation>\) column)))
    (relation-column-setter (lambda (\(r\ <relation>\) column)))
    (relation-ref (lambda (\(r\ <relation>\) row column :optional default)))
    (relation-set! (lambda (\(r\ <relation>\) row column value)))
    (relation-column-getters (lambda (\(r\ <relation>\))))
    (relation-column-setters (lambda (\(r\ <relation>\))))
    (relation-coercer (lambda (\(r\ <relation>\))))
    (relation-insertable\? (lambda (\(r\ <relation>\))))
    (relation-insert! (lambda (\(r\ <relation>\) row)))
    (relation-deletable\? (lambda (\(r\ <relation>\))))
    (relation-delete! (lambda (\(r\ <relation>\) row)))
    (relation-fold (lambda (\(r\ <relation>\) proc seed column \.\.\.)))
    (cgi-metavariables (lambda (:optional metavariables)))
    (cgi-output-character-encoding (lambda (:optional encoding)))
    (cgi-temporary-files (lambda nil))
    ))



(defconst gosh-info-appendixes-ja
  '(
    ("(gauche-refj.info)Index - " nil 
     "^[ \t]+-- [^:]+:[ \t]*" nil)
    ("(gauche-refj.info)Index - "   nil
     "^[ \t]+-- [^:]+:[ \t]*" nil)
    ("(gauche-refj.info)Index - "      nil
     "^[ \t]+-- [^:]+:[ \t]*" nil)
    ("(gauche-refj.info)Index - "        nil
     "^[ \t]+-- [^:]+:[ \t]*" nil)))

(defconst gosh-info-appendixes-en
  '(("(gauche-refe.info)Function and Syntax Index" nil 
     "^[ \t]+-- [^:]+:[ \t]*" nil)
    ("(gauche-refe.info)Module Index"   nil
     "^[ \t]+-- [^:]+:[ \t]*" nil)
    ("(gauche-refe.info)Class Index"      nil
     "^[ \t]+-- [^:]+:[ \t]*" nil)
    ("(gauche-refe.info)Variable Index"        nil
     "^[ \t]+-- [^:]+:[ \t]*" nil)))

(defvar gosh-info-appendixes
  (if (and current-language-environment
           (string= current-language-environment "Japanese"))
      gosh-info-appendixes-ja
    gosh-info-appendixes-en))


(provide 'gosh-const)

;;; gosh-const.el ends here
